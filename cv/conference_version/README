* The following files prove several lemmas about the key schedule,
in order to simplify other proofs.

HKDFexpand.cv
KeySchedule1.cv
KeySchedule2.cv
KeySchedule3.cv

* The following files prove the initial handshake (without PSK)

tls13-core-InitialHandshake-LeakKeysIfCorrupted.cv
	==> proves that the client and server traffic secrets 0, the exporter secret
	and the resumption secret are independent secrets.

tls13-core-InitialHandshake-SecrecyServerSide.cv
	==> Other version of the previous file in which we prove
	secrecy of the keys also on the server side, but do not leak
	the keys if the server if corrupted.
	(The version above is better, but it is still reassuring to
	see that the keys are secret on the server side as well.)

* The following file proves the handshake with PSK (and optionally DHE)

tls13-core-PSKandPSKDHE-NoCorruption.cv
	==> proves that the client and server traffic secrets 0, the exporter secret
	the resumption secret, the client early traffic secret, and the
	early exported secret and independent secrets,
	as well as correspondences.
	
* The following file deals with the record protocol:

tls13-core-RecordProtocol.cv
	==> proves secrecy of the plaintexts and message authenticity,
	assuming the traffic_secret_N+1 is leaked, and secrecy of traffic_secret_N+1.

==========================================================================

What does not work:
- use DDH rather than GDH
- prove forward secrecy for PSKDHE (needs ROM for the second extraction
plus extension of dependency analysis)
- DONE prove the absence of bilateral UKS attacks (needs other assumptions)

- Discuss [Application Data*] sent from Server to Client with the ServerHello.
- DH groups have prime order (OK see below)
- Are DH group elements different from 0 (Added as assumption)
- Use different signature algorithms for the client and the server?

TO DO
- Use probabilities coming from lemmas in the proofs.
- DONE (minimally) Write a library for the definitions of primitives?

==========================================================================
Probabilities:

HKDFexpand:
The probability of distinguishing processLeft and processRight given by CryptoVerif is
2 * N3 * (Pprf(time + N3 * T + 3 * (N3-1) * time(HMAC, L), 3, L) + 2 / |key|)
where
T = time(build_arg, length(l3)) + time(build_arg, length(l2)) + time(build_arg, length(l1))
L = max(length(build_arg, length(l1)), length(build_arg, length(l2)), length(build_arg, length(l3)))

KeySchedule1:
The probability of distinguishing processLeft and processRight given by CryptoVerif is
18 * Phashcoll + 
2 * N3 * Pprf(time + T + (N3-1)(2N + N'' + 2) * time(HMAC, L), 2N + N'' + 2, L) + 
4 * N3 / |extracted|
where
L = max(length(build_arg, length(eems)), 
        length(build_arg, length(client_ets)), 
	length(build_arg, length(psk_binder_key)), 
	length(elt2bitstring), 
	length(zero_hash))

T = N3 * time(build_arg, length(psk_binder_key)) + 
    N3 * time(Hash, length(empty_log)) + 
    N * N3 * time(build_arg, length(client_ets)) + 
    2 * N * N3 * time(Hash, maxlength(log0)) + 
    N * N3 * time(build_arg, length(eems)) + 
    N * N3 * time(concat)

KeySchedule2:
The probability of distinguishing processLeft and processRight given by CryptoVerif is
12 * Phashcoll + 
2 * N3 * Pprf(time + T + (N3-1)(2N+1) * time(HMAC, L), 2N+1, L) + 
4 * N3 / |extracted|
where
T = N * N3 * time(build_arg, length(client_hts)) + 
    2 * N * N3 * time(Hash, maxlength(log0)) + 
    N * N3 * time(build_arg, length(server_hts)) + 
    N * N3 * time(concat) 
L = max(length(build_arg, length(server_hts)), 
        length(build_arg, length(client_hts)), 
        length(zero))

KeySchedule3:
The probability of distinguishing processLeft and processRight given by CryptoVerif is
40 * Phashcoll
2 * N3 * Pprf(time + T + (N3-1)(3N+N') * time(HMAC, L), 3N+N', L) + 
4 * N3 / |extracted|
where
T = N' * N3 * time(Hash, maxlength(log0')) + 
    N' * N3 * time(build_arg, length(resumption_ms)) + 
    N * N3 * time(build_arg, length(client_ats)) + 
    N * N3 * time(build_arg, length(server_ats)) + 
    3. * N * N3 * time(Hash, maxlength(log0)) + 
    N * N3 * time(build_arg, length(exporter_ms)) + 
    N * N3 * time(concat)
L = max(length(build_arg, length(exporter_ms)), 
        length(build_arg, length(server_ats)), 
        length(build_arg, length(client_ats)), 
        length(build_arg, length(resumption_ms)))

(I made some simplifications, e.g. ignore the time of bitstring comparisons.
There is a spurious factor 2 that comes from the fact that the proof is done
via secrecy of a bit b in "if b then P1 else P2".
The probability Phashcoll should in fact be counted only once.)

==================================================================
DH groups

/* Elliptic Curve Groups (ECDHE) */
secp256r1 (23), OK all of prime order by NIST FIPS 186-3 
secp384r1 (24),
secp521r1 (25),
x25519 (29), OK prime order
x448 (30), by https://eprint.iacr.org/2015/625.pdf the curve is of order 4.q (q prime);
     	   The DH subgroup has order q (the generator is the point of order q with least u-coordinate).

/* Finite Field Groups (DHE) */
ffdhe2048 (256),
ffdhe3072 (257),
ffdhe4096 (258),
ffdhe6144 (259),
ffdhe8192 (260),
OK: the modulus is a safe prime p (that is, q = (p-1)/2 is
also prime) and the group size is exactly q = (p-1)/2.
See https://tools.ietf.org/html/rfc7919
