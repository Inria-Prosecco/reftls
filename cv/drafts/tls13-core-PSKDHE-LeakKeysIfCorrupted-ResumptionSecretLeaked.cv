
channel io1, io2, io3, io4, io5, io6, io7, io8, io9, io10,
	io11, io12, io13, io14, io15, io16, io17, io18, io19, io20,
	io21, io22, io23, io24, io25, io26, io27, io28, io29, io30,
	cCorrupt.

proof {
      crypto rom(HKDF_extract_zero_salt);
      out_game "g1.out" occ;
      insert 372 "find j' <= N1 suchthat defined(gx_292[j']) && sgx = gx_292[j'] then";
      SArename gy_363;
      out_game "g2.out" occ;
      insert 66 "find j'' <= N6 suchthat defined(gy_469[j''], sgx[j'']) && gx_292 = sgx[j''] && cgy = gy_469[j''] then";
      crypto prf1;
      remove_assign binder s_310;
      remove_assign binder s_364;
      simplify;
      crypto gdh(exp) "variables: x_291 -> @4_a, y_472 -> @4_b .";
      interactive;
      crypto prf2 *;
      crypto client_server_hts *;
      crypto prf_fin_key_iv *;
      crypto prf3 *;
      crypto client_server_ats_exporter_ms *;
      crypto suf_cma(mac) *; 
      simplify;
      out_game "g3.out";
      move binder s_sfl; (* needed in order to move @9_ma2_3149, because s_sfl uses it *)
      move binder "@9_ma2_2547";
      SArename "@9_ma2_2547";
      move binder "@9_ma2_3149";
      SArename "@9_ma2_3149";
      success;
      crypto uf_cma_corrupt(sign) kseedC;
      success;
      SArename r'_771;
      SArename r'_777;
      SArename r'_781;
      SArename r'_787;
      out_game "g4.out";
      move binder "@9_ma2_2673";
      SArename "@9_ma2_2673";
      move binder "@9_ma2_2689";
      SArename "@9_ma2_2689";
      move binder "@9_ma2_2677";
      SArename "@9_ma2_2677";
      move binder "@9_ma2_2693";
      SArename "@9_ma2_2693";
      move binder "@9_ma2_1617";
      SArename "@9_ma2_1617";
      move binder "@9_ma2_1633";
      SArename "@9_ma2_1633";
      move binder "@9_ma2_1621";
      SArename "@9_ma2_1621";
      move binder "@9_ma2_1637";
      SArename "@9_ma2_1637";
      success
}



type key [large, fixed].
const zero_key: key.
type extracted [large, fixed].
const zero_extracted: extracted. 

type elt [large, bounded].
fun element2key(elt): key [compos].
fun elt2bitstring(elt): bitstring [compos].

(* Gap Diffie-Hellman assumption.
   The considered groups are prime order. *)

proba pGDH.
expand GDH_prime_order(elt, key, G, exp, mult, pGDH).

letfun dh_keygen() =
   new x:key;
   (x,exp(G,x)).

param N, N', N'', N2, N3, N4.

(* HKDF_extract_zero_salt, that is, HKDF_extract with salt argument 
   0, is a random oracle. *)

type hashkey [large,fixed].

expand ROM_hash(hashkey, key, extracted, HKDF_extract_zero_salt).

param qH [noninteractive].
channel c1, c2.
let hashoracle = ! qH in(c1, x:key); out(c2, HKDF_extract_zero_salt(hk,x)). 

(* We use the lemma proved in KeySchedule1.cv *)

type two_keys [large,fixed].
fun Derive_Secret_cets_eems(extracted, bitstring): two_keys.
fun Derive_Secret_psk_binder_key(extracted): key.
fun HKDF_extract_DHE(extracted, elt): extracted.

proba Pprf1.

equiv prf1
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cets_eems(k, log),
		              O2() := Derive_Secret_psk_binder_key(k),
			      !N'' O3(DHE: elt) := HKDF_extract_DHE(k, DHE))
     <=(N3 * Pprf1(time + (N3-1)*(time(Derive_Secret_psk_binder_key) + N * time(Derive_Secret_cets_eems, maxlength(log)) + N'' * time(HKDF_extract_DHE)), N, N''))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: two_keys; r,
	    O2() := new r': key; r',
	    !N'' O3(DHE: elt) :=
	        find[unique] j''<=N'' suchthat defined(DHE[j''],r''[j'']) && DHE = DHE[j''] then r''[j''] 
		else new r'': extracted; r'').
       
fun get_client_ets(two_keys): key.
fun get_eets(two_keys): key.

equiv cets_eems
      !N new r: two_keys; (O1() := get_client_ets(r),
      	    	           O2() := get_eets(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2).

(* We use the lemma proved in KeySchedule2.cv *)

fun Derive_Secret_cs_hts(extracted,bitstring):two_keys.
fun HKDF_extract_zero(extracted):extracted.


proba Pprf2.

equiv prf2
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cs_hts(k, log),
		              O2() := HKDF_extract_zero(k))
     <=(N3 * Pprf2(time + (N3-1)*(time(HKDF_extract_zero) + N * time(Derive_Secret_cs_hts, maxlength(log))), N))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: two_keys; r,
	    O2() := new r': extracted; r').

fun get_client_hts(two_keys): key.
fun get_server_hts(two_keys): key.

equiv client_server_hts
      !N new r: two_keys; (O1() := get_client_hts(r),
      	    	           O2() := get_server_hts(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2).

(* We use the lemma proved in KeySchedule3.cv *)

type three_keys [large, fixed].
fun Derive_Secret_cs_ats_exp(extracted, bitstring): three_keys.
fun Derive_Secret_rms(extracted, bitstring): key.

proba Pprf3.

equiv prf3
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cs_ats_exp(k, log),
		              !N' O2(log': bitstring) := Derive_Secret_rms(k, log'))
     <=(N3 * Pprf2(time + (N3-1)*(N' * time(Derive_Secret_rms, maxlength(log')) + N * time(Derive_Secret_cs_ats_exp, maxlength(log))), N, N'))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: three_keys; r,
	    !N' O2(log':bitstring) :=
	        find[unique] j'<=N' suchthat defined(log'[j'],r'[j']) && log' = log'[j'] then r'[j'] 
		else new r': key; r').      

fun get_client_ats(three_keys): key.
fun get_server_ats(three_keys): key.
fun get_exporter_ms(three_keys): key.

equiv client_server_ats_exporter_ms
      !N new r: three_keys; (O1() := get_client_ats(r),
      	    	             O2() := get_server_ats(r),
			     O3() := get_exporter_ms(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2,
	  O3() := new r3: key; r3).

(* We use the lemma proved in HKDFexpand.cv *)

fun HKDF_expand_fin_label(key): key.
fun HKDF_expand_key_label(key): key.
fun HKDF_expand_iv_label(key): key.

proba Pprf_fin_key_iv.

equiv prf_fin_key_iv
      !N3 new r: key; (O1() := HKDF_expand_fin_label(r),
      	      	       O2() := HKDF_expand_key_label(r),
		       O3() := HKDF_expand_iv_label(r))
    <=(N3 * Pprf_fin_key_iv(time + (N3-1)*(time(HKDF_expand_fin_label) + time(HKDF_expand_key_label) + time(HKDF_expand_iv_label))))=>
      !N3 (O1() := new r1: key; r1,
      	   O2() := new r2: key; r2,
	   O3() := new r3: key; r3).

(* SUF-CMA MAC
   The MAC is actually a combination of a hash followed by a MAC.
   It is easy to see that the combination is SUF-CMA provided the MAC is SUF-CMA 
   and the hash is collision resistant. *)

proba Pmac.
expand SUF_CMA_mac_nokgen(key, bitstring, bitstring, mac, check, Pmac).

(* Message formats *)

type nonce [large, fixed].
type certificate.

fun ClientHelloOut(nonce, elt): bitstring [compos].
fun ClientHelloIn(nonce, elt, bitstring): bitstring [compos].
fun ServerHelloIn(nonce, elt, bitstring): bitstring [compos].
fun ServerHelloOut(nonce, elt): bitstring [compos].
fun ServerFinishedIn(bitstring,bitstring): bitstring [compos].
fun ServerFinishedOut(bitstring): bitstring [compos].

fun ClientFinishedOut(bitstring): bitstring  [compos].
fun ClientFinishedIn(bitstring,bitstring): bitstring  [compos].

(* Logs *)

fun ClientHelloLogInfo(nonce,elt,bitstring): bitstring [compos].
fun ServerHelloLogInfo(bitstring,nonce,elt,bitstring): bitstring [compos].
fun ServerBeforeFinishedLogInfo(bitstring,bitstring): bitstring [compos].
fun ServerFinishedLogInfo(bitstring,bitstring): bitstring [compos].
fun ClientBeforeFinishedLogInfo(bitstring, bitstring): bitstring [compos].
fun ClientFinishedLogInfo(bitstring, bitstring): bitstring [compos].

(* Secrecy of the key *)

query secret client_ts0_secret_c.
query secret server_ts0_secret_c.

(* Authentication of the server to the client *)

event ClientTerm(nonce,elt,bitstring,nonce,elt,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key).
event ServerAccept(nonce,elt,bitstring,nonce,elt,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key).

query cr: nonce, gx: elt, log1: bitstring, sr: nonce, gy: elt, log2: bitstring, log3: bitstring, m: bitstring,
      client_hk: key, server_hk: key, client_hiv: key, server_hiv: key, cfk: key, sfk: key, client_ts0: key, server_ts0: key;
      event inj:ClientTerm(cr,gx,log1,sr,gy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0) ==>
      	    inj:ServerAccept(cr,gx,log1,sr,gy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0).

(* Authentication of the client to the server *)

event ServerTerm(nonce,elt,bitstring,nonce,elt,bitstring,bitstring,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key,key).
event ClientAccept(nonce,elt,bitstring,nonce,elt,bitstring,bitstring,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key,key).

query cr: nonce, gx: elt, log1: bitstring, sr: nonce, gy: elt, log2: bitstring,
      log3: bitstring, m: bitstring, log4: bitstring, cfin: bitstring, client_hk: key, server_hk: key,
      client_hiv: key, server_hiv: key, cfk: key, sfk: key, client_ts0: key, server_ts0: key,
      res_secret: key;
      event inj:ServerTerm(cr,gx,log1,sr,gy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,res_secret) ==>
      	    inj:ClientAccept(cr,gx,log1,sr,gy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,res_secret).



letfun send_client_hello(earlySecret: extracted, log1: bitstring) = 
   new cr:nonce;
   new x:key;
   let gx = exp(G,x) in
   let chl = ClientHelloLogInfo(cr,gx,log1) in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   let client_ets = get_client_ets(cets_eems) in
   (cr,x,gx, client_ets).


letfun recv_server_hello(earlySecret: extracted, sil:bitstring, x:key) = 
  let ServerHelloLogInfo(chl,sr,gy,l2) = sil in
  (let s = exp(gy,x) in
   let handshakeSecret = HKDF_extract_DHE(earlySecret, s) in
   let cs_hts = Derive_Secret_cs_hts(handshakeSecret,sil) in
   let client_hts = get_client_hts(cs_hts) in
   let server_hts = get_server_hts(cs_hts) in
   let client_hk = HKDF_expand_key_label(client_hts) in
   let server_hk = HKDF_expand_key_label(server_hts) in
   let client_hiv = HKDF_expand_iv_label(client_hts) in
   let server_hiv = HKDF_expand_iv_label(server_hts) in
   let cfk = HKDF_expand_fin_label(client_hts) in
   let sfk = HKDF_expand_fin_label(server_hts) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (masterSecret,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,true))
  else (zero_extracted,zero_key,zero_key,zero_key,zero_key,zero_key,zero_key,false).
   

letfun recv_server_finished(sil:bitstring, masterSecret:extracted, sfk: key,
       		            m:bitstring, 
			    log3:bitstring) =
   let scvl = ServerBeforeFinishedLogInfo(sil, log3) in
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let cs_ats_exp = Derive_Secret_cs_ats_exp(masterSecret,sfl) in
   let client_ts0 = get_client_ats(cs_ats_exp) in
   let server_ts0 = get_server_ats(cs_ats_exp) in
   (client_ts0,server_ts0, mac(sfk,scvl) = m).
			   
letfun send_client_finished(log:bitstring, cfk:key) = 
   mac(cfk,log).

letfun get_resumption_secret(masterSecret: extracted, cfl: bitstring) =
   Derive_Secret_rms(masterSecret, cfl).

letfun recv_client_hello(earlySecret: extracted, cr:nonce, gx:elt, log1: bitstring) = 
   let chl = ClientHelloLogInfo(cr,gx,log1) in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   let client_ets = get_client_ets(cets_eems) in
   new sr:nonce;
   new y: key;
   let gy = exp(G,y) in
   let s = exp(gx,y) in
   let handshakeSecret = HKDF_extract_DHE(earlySecret,s) in   
   (sr,gy,handshakeSecret,client_ets).

letfun onertt_hs_keys(sil:bitstring,handshakeSecret:extracted) = 
   let cs_hts = Derive_Secret_cs_hts(handshakeSecret,sil) in
   let client_hts = get_client_hts(cs_hts) in
   let server_hts = get_server_hts(cs_hts) in
   let client_hk = HKDF_expand_key_label(client_hts) in
   let server_hk = HKDF_expand_key_label(server_hts) in
   let client_hiv = HKDF_expand_iv_label(client_hts) in
   let server_hiv = HKDF_expand_iv_label(server_hts) in
   let cfk = HKDF_expand_fin_label(client_hts) in
   let sfk = HKDF_expand_fin_label(server_hts) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (client_hk, server_hk, client_hiv, server_hiv, cfk, sfk, masterSecret).

letfun send_server_finished(scvl:bitstring,sfk:key) = 
   mac(sfk,scvl).

letfun onertt_data_keys(masterSecret: extracted, sfl:bitstring) = 
   let cs_ats_exp = Derive_Secret_cs_ats_exp(masterSecret,sfl) in
   let client_ts0 = get_client_ats(cs_ats_exp) in
   let server_ts0 = get_server_ats(cs_ats_exp) in
   (client_ts0, server_ts0).

letfun check_client_finished(masterSecret: extracted, ccvl:bitstring,cfin:bitstring,cfk:key) = 
   if mac(cfk,ccvl) = cfin then
   (
       let cfl = ClientFinishedLogInfo(ccvl, cfin) in
       let resumption_secret = Derive_Secret_rms(masterSecret, cfl) in
       (resumption_secret, true)
   )
   else
       (zero_key, false).


param N1,N5,N6,
      N7,N8,N9,N10,N11,N12,
      N13,N14,N15,N16.

let Client = 
!N1
    in(io1,log1: bitstring);
    let (cr:nonce,x:key,cgx:elt, client_ets: key) = send_client_hello(earlySecret, log1) in
    let chl = ClientHelloLogInfo(cr,cgx,log1) in
    (* for 0-rtt  insert clientEphemeralKeys(cr,x,cgx); *)
    out(io2,(ClientHelloOut(cr,cgx), client_ets));
    in(io3,ServerHelloIn(sr,cgy,log2));
    let sil = ServerHelloLogInfo(chl,sr,cgy,log2) in
    let (masterSecret:extracted,client_hk:key,server_hk:key,client_hiv:key,server_hiv:key,cfk:key,sfk:key,=true) = recv_server_hello(earlySecret,sil,x) in
    out(io4,(client_hk, server_hk, client_hiv, server_hiv));
    in(io5,(ServerFinishedIn(log3,m), ClientAuth: bool, log4: bitstring)); 
    let (client_ts0:key,server_ts0:key,=true) = recv_server_finished(sil,masterSecret,sfk,m,log3) in   
    let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
    let c_sfl : bitstring = ServerFinishedLogInfo(scvl,m) in
    let ccvl = ClientBeforeFinishedLogInfo(c_sfl,log4) in
    let cfin = send_client_finished(ccvl,cfk) in
    let cfl = ClientFinishedLogInfo(ccvl, cfin) in
    let resumption_secret = get_resumption_secret(masterSecret, cfl) in
    event ClientAccept(cr,cgx,log1,sr,cgy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,resumption_secret);
    if defined(corruptedPSK) then
    	out(io6,ClientFinishedOut(cfin));
       	in(io7,());
       	out(io8, (resumption_secret, client_ts0, server_ts0))
    else
    	out(io6,ClientFinishedOut(cfin));
       	in(io7,());
        (* The client is talking to the honest server.
           Check that the shared key is secret. *)
        event ClientTerm(cr,cgx,log1,sr,cgy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0);
	let client_ts0_secret_c: key = client_ts0 in
	let server_ts0_secret_c: key = server_ts0 in
	out(io8, resumption_secret).

let Server = 
 !N6
   in(io9,ClientHelloIn(cr,sgx,log1));
   let (sr:nonce,sgy:elt,handshakeSecret:extracted, client_ets: key) = recv_client_hello(earlySecret,cr,sgx,log1) in
   let chl = ClientHelloLogInfo(cr,sgx,log1) in
   out(io10,(ServerHelloOut(sr,sgy), client_ets));
   in(io11,log2:bitstring);
   let sil = ServerHelloLogInfo(chl,sr,sgy,log2) in
   let (client_hk:key, server_hk: key, client_hiv: key, server_hiv: key, cfk: key, sfk: key, masterSecret: extracted) = onertt_hs_keys(sil,handshakeSecret) in
   out(io12,(client_hk, server_hk, client_hiv, server_hiv));
   in(io13,log3:bitstring);
   let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
   let m = send_server_finished(scvl,sfk) in
   let s_sfl = ServerFinishedLogInfo(scvl,m) in
   let (client_ts0: key, server_ts0: key) = onertt_data_keys(masterSecret,s_sfl) in
   event ServerAccept(cr,sgx,log1,sr,sgy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0);
   out(io18,ServerFinishedOut(m));
   in(io19,ClientFinishedIn(log4, cfin));
   let ccvl = ClientBeforeFinishedLogInfo(s_sfl,log4) in
   let (resumption_secret: key, =true) = check_client_finished(masterSecret,ccvl,cfin,cfk) in
   if defined(corruptedPSK) then
       find j <= N1 suchthat defined(c_sfl[j]) && s_sfl = c_sfl[j] then
       	   (* The client has the same key in session j. 
	      The secrecy of the traffic secrets client_ts0, server_ts0 is proved at the client. *)
	   out(io30, resumption_secret)
       else
	   out(io30, (resumption_secret, client_ts0, server_ts0))
   else 	   
       event ServerTerm(cr,sgx,log1,sr,sgy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,resumption_secret);
       (* By the correspondence ServerTermAuth ==> ClientAcceptAuth, the client has the same key.
      	  The secrecy of the traffic secrets client_ts0, server_ts0 is proved at the client. *)
       out(io30, resumption_secret).

(* Corruption for forward secrecy *)

let corrupt = 
  in(cCorrupt, ()); 
  let corruptedPSK:bool = true in
  out(cCorrupt, PSK).

process 
  in(io20,());
  new hk: hashkey; (* Key that models the choice of the random oracle *)
  new PSK: key;
  let earlySecret = HKDF_extract_zero_salt(hk, PSK) in
  out(io21,());
  (Client | Server | corrupt | hashoracle)
