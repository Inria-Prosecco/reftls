
channel io1, io1', io2, io2', io3, io4, io5, io6, io7, io8, io9, io10,
	io11, io12, io13, io14, io15, io16, io17, io18, io19, io20,
	io21, io22, io23, io24, io25, io26, io27, io28, io29, io30,
	cCorrupt.

proof {
      crypto rom(HKDF_extract_zero_salt);
      crypto prf1;
      crypto suf_cma(mac) *;       
      out_game "g1.out" occ;
      SArename gy_379;
      remove_assign binder s_320;
      remove_assign binder s_380;
      remove_assign binder DHE_490;
      remove_assign binder DHE_485;
      crypto gdh(exp) "variables: x_288 -> @4_a, y_512 -> @4_b, y_514 -> @4_b, y_510 -> @4_b .";
      crypto prf2 *;
      crypto client_server_hts *;
      crypto prf_fin_key_iv *;
      crypto prf3 *;
      crypto client_server_ats_exporter_ms *;
      crypto suf_cma(mac) *; 
      simplify;
      success;
      out_game "g2.out";
      move binder "@9_ma2_1043";
      SArename "@9_ma2_1043";
      move binder "@9_ma2_1127";
      SArename "@9_ma2_1127";
      success;
      out_game "g3.out";      
      move binder "@9_ma2_1087";
      SArename "@9_ma2_1087";
      move binder "@9_ma2_1001";
      SArename "@9_ma2_1001";
      success
}



type key [large, fixed].
const zero_key: key.
type extracted [large, fixed].
const zero_extracted: extracted. 

type elt [large, bounded].
fun element2key(elt): key [compos].
fun elt2bitstring(elt): bitstring [compos].

(* Gap Diffie-Hellman assumption.
   TO DO are the groups prime order? *)

define GDH_prime_order(G, Z, g, exp, mult, pGDH) {

fun exp(G,Z): G.
fun exp'(G,Z): G.
const g:G.

fun mult(Z,Z): Z. 
equation commut(mult).

(* exponents multiply *)

forall a:G, x:Z, y:Z;
  exp(exp(a,x), y) = exp(a, mult(x,y)).
forall a:G, x:Z, y:Z;
  exp'(exp'(a,x), y) = exp'(a, mult(x,y)).

(* injectivity *)

forall x:Z, y:Z; (exp(g,x) = exp(g,y)) = (x = y).
forall x:Z, y:Z; (exp'(g,x) = exp'(g,y)) = (x = y).

(* According to http://link.springer.com/chapter/10.1007%2F11745853_14,
page 214, the order of the base point is a prime
namely 2^252 + 27742317777372353535851937790883648493.
So exp(x,y) = exp(x',y) implies y = y' (provided y is not a multiple
of this prime; if y is a correctly generated secret key, that cannot
happen)
-- TO DO check for TLS what groups are used *)

forall x:G, x':G, y:Z; (exp(x,y) = exp(x',y)) = (x = x').
forall x:G, x':Z, y:Z; (exp(x,y) = exp(g, mult(x',y))) = (x = exp(g,x')).

forall x:G, y:Z, y':Z; (exp(x,y) = exp(x,y')) = (y = y').

(* collision between products *)

collision new x1:Z; new x2:Z; new x3:Z; new x4:Z; 
  mult(x1,x2) = mult(x3,x4) <=(1/|Z|)=> false. 

collision new x1:Z; new x2:Z; 
  mult(x1,x1) = mult(x2,x2) <=(1/|Z|)=> false. 

forall x:Z, y:Z, y':Z; 
  (mult(x,y) = mult(x,y')) = (y = y').

(* replace a random group element with an exponentiation, and conversely *)

param N, N'.

equiv group_to_exp_strict(exp)
      !N new X:G; (OX() := X, !N' OXm(m:Z) [useful_change] := exp(X,m))
<=(0)=> [computational]
      !N new x:Z; (OX() := exp(g,x), !N' OXm(m:Z) := exp(g,mult(x,m))).

(* This equivalence is very general, apply it only manually, because
   otherwise it might be applied too often.  The equivalence above is
   particular case applied only when X is inside exp, and good for
   automatic proofs. *)

equiv group_to_exp(exp)
      !N new X:G; OX() := X 
<=(0)=> [manual, computational]    
      !N new x:Z; OX() := exp(g,x).


equiv exp_to_group(exp)
      !N new x:Z; OX() := exp(g,x)
<=(0)=> [computational]
      !N new X:G; OX() := X.

equiv exp'_to_group(exp)
      !N new x:Z; OX() := exp'(g,x)
<=(0)=> [computational]
      !N new X:G; OX() := X.

(* the GDH assumption
    This equivalence says that, when exp(g,a[i]) and exp(g,b[j]) are known to the
    adversary, the adversary can compute exp(g, mult(a[i], b[j])) only with
    negligible probability, even in the presence of a DDH oracle
    DDH(G,A,B,C) tells whether A = G^a, B = G^b, and C = G^{ab} for some a,b,
    that is DDH(G,A,B,C) is (log_G(A) * log_G(B) = log_G(C)). *) 

const mark: bitstring.

param na, naDDH, naDDH1, naDDH2, naDDH3, naDDH4, naDDH5, naDDH6, naDDH7, naDDH8,
      nb, nbDDH, nbDDH1, nbDDH2, nbDDH3, nbDDH4, nbDDH5, nbDDH6, nbDDH7, nbDDH8.

equiv gdh(exp)
    !na new a:Z; (
      OA() := exp(g,a), 
      Oa() [3] := a,
      !naDDH1 ODDHa1(m:G, m':G) := m = exp(m', a),
      !naDDH2 ODDHa2(m:G,m':G,j<=nb) := exp(m, b[j]) = exp(m',a),
      !naDDH3 ODDHa3(m:G,m':G,j<=na) := exp(m, a[j]) = exp(m',a),
      !naDDH4 ODDHa4(m:G,j'<=nb,j<=nb) [useful_change] := exp(m, b[j]) = exp(g,mult(b[j'],a)),
      !naDDH5 ODDHa5(m:G,j'<=nb,j<=na) [useful_change] := exp(m, a[j]) = exp(g,mult(b[j'],a)),
      !naDDH6 ODDHa6(m:G,j'<=na,j<=nb) := exp(m, b[j]) = exp(g,mult(a[j'],a)),
      !naDDH7 ODDHa7(m:G,j'<=na,j<=na) := exp(m, a[j]) = exp(g,mult(a[j'],a)),
      !naDDH ODDHa(m:G, j<=nb) [useful_change] := m = exp(g, mult(b[j], a)),
      !naDDH8 ODDHa8(m:G,j<=na) [3] := m = exp(g,mult(a[j], a))
    ),
    !nb new b:Z; (
      OB() := exp(g,b),
      Ob() [3] := b,
      !nbDDH1 ODDHb1(m:G, m':G) := m = exp(m', b),
      !nbDDH2 ODDHb2(m:G,m':G,j<=nb) := exp(m, b[j]) = exp(m',b),
      !nbDDH3 ODDHb3(m:G,m':G,j<=na) := exp(m, a[j]) = exp(m',b),
      !nbDDH4 ODDHb4(m:G,j'<=nb,j<=nb) := exp(m, b[j]) = exp(g,mult(b[j'],b)),
      !nbDDH5 ODDHb5(m:G,j'<=nb,j<=na) := exp(m, a[j]) = exp(g,mult(b[j'],b)),
      !nbDDH6 ODDHb6(m:G,j'<=na,j<=nb) := exp(m, b[j]) = exp(g,mult(a[j'],b)),
      !nbDDH7 ODDHb7(m:G,j'<=na,j<=na) := exp(m, a[j]) = exp(g,mult(a[j'],b)),
      !nbDDH ODDHb(m:G, j<=na) := m = exp(g, mult(a[j], b)),
      !nbDDH8 ODDHb8(m:G,j<=nb) [3] := m = exp(g,mult(b[j], b))
    )
<=((#ODDHa + #ODDHa1 + #ODDHa4 + #ODDHa5 + #ODDHb + #ODDHb1 + #ODDHb6 + #ODDHb7) *
	   max(1, 7.4*#Oa) * max(1, 7.4*#Ob) *
	   pGDH(time + (na + nb + #ODDHa + #ODDHa1 + #ODDHb + #ODDHb1) * time(exp),
	   #ODDHa1 + #ODDHa2 + #ODDHa3 + #ODDHa4 + #ODDHa5 + #ODDHa6 + #ODDHa7 + #ODDHa8 +
	   #ODDHb1 + #ODDHb2 + #ODDHb3 + #ODDHb4 + #ODDHb5 + #ODDHb6 + #ODDHb7 + #ODDHb8))=> [computational]
    !na new a:Z [unchanged]; (
      OA() := exp'(g,a), 
      Oa() := let ka:bitstring = mark in a,
      !naDDH1 ODDHa1(m:G, m':G) := if defined(ka) then m = exp'(m', a) else 
      		  	   find u<=nb suchthat defined(b[u],kb[u]) && m' = exp'(g,b[u]) then m = exp'(m', a) else
			   find u<=nb suchthat defined(b[u]) && m' = exp'(g,b[u]) then false else
                               (* by CDH, if neither a nor b[u] are leaked, then m = exp(g, b[u]*a) is impossible *)
			   m = exp'(m', a)
			       (* GDH allows to compute m = exp(m',a) for any m and m', without leaking a, 
			          as it is DDH(g, exp(g,a), m', m) *),
      !naDDH2 ODDHa2(m:G,m':G,j<=nb) := exp'(m, b[j]) = exp'(m',a),
      	   (* GDH allows to compute exp(m, b[j]) = exp(m',a) for any m and m', 
	      without leaking a, as it is DDH(exp(g,a), exp(g,b[j]), m, m')
	      Indeed, 
 	      D(exp(g,a),exp(g,b[j]),m,m') 
      	        = (log_{g^a}(g^b[j]) * log_{g^a}(m) = log_{g^a}(m'))
      		= (b[j]/a * log_g(m)/a = log_g(m')/a)
      		= (b[j] * log_g(m) = a log_g(m'))
      		= (m^b[j] = m'^a). *)
      !naDDH3 ODDHa3(m:G,m':G,j<=na) := exp'(m, a[j]) = exp'(m',a),
      	    (* Similar to ODDHa2 *)
      !naDDH4 ODDHa4(m:G,j'<=nb,j<=nb) :=
      	      find u<=nb suchthat defined(kb[u],b[u]) && b[j'] = b[u] then exp'(m, b[j]) = exp'(g,mult(b[j'],a)) else
	      if defined(ka) then exp'(m, b[j]) = exp'(g,mult(b[j'],a)) else
      	      b[j] = b[j'] && m = exp'(g,a),
      !naDDH5 ODDHa5(m:G,j'<=nb,j<=na) :=
      	      find u<=nb suchthat defined(kb[u],b[u]) && b[j'] = b[u] then exp'(m, a[j]) = exp'(g,mult(b[j'],a)) else
	      if defined(ka) then exp'(m, a[j]) = exp'(g,mult(b[j'],a)) else
      	      a[j] = a && m = exp'(g,b[j']),
      !naDDH6 ODDHa6(m:G,j'<=na,j<=nb) := exp'(m, b[j]) = exp'(g,mult(a[j'],a)),
      !naDDH7 ODDHa7(m:G,j'<=na,j<=na) := exp'(m, a[j]) = exp'(g,mult(a[j'],a)),
            (* ODDHa4..7 are particular cases of ODDHa2 or ODDHa3, with m' = exp(g, b[j'])
	       or m' = exp(g, a[j']).
	       We need to consider all these forms because CryptoVerif rewrites
	       exp(exp(g,b[j']),a) into exp(g,mult(b[j'],a)), and it would not
	       detect exp(g,mult(b[j'],a)) as an instance of exp(m',a). *)
      !naDDH ODDHa(m:G, j<=nb) :=
      	     find u<=nb suchthat defined(kb[u],b[u]) && b[j] = b[u] then m = exp'(g, mult(b[j], a)) else 
             if defined(ka) then m = exp'(g, mult(b[j], a)) else false,
	    (* ODDHa is a particular case of ODDHa1 in which can apply the CDH assumption,
	       provided a and b[j] are not leaked. *)
      !naDDH8 ODDHa8(m:G,j<=na) := m = exp'(g,mult(a[j], a))
            (* ODDHa8 is a particular case of ODDHa1 in which we do not apply
	       the CDH assumption, since we apply it between a's and b's *)
    ),
    !nb new b:Z [unchanged]; (
      OB() := exp'(g,b), 
      Ob() := let kb:bitstring = mark in b,
      !nbDDH1 ODDHb1(m:G, m':G) := if defined(kb) then m = exp'(m', b) else 
      		  	   find u<=na suchthat defined(a[u],ka[u]) && m' = exp'(g,a[u]) then m = exp'(m', b) else
      		  	   find u<=na suchthat defined(a[u]) && m' = exp'(g,a[u]) then false else
                               (* by CDH, if neither a nor b[u] are leaked, then m = exp(g, a[u]*b) is impossible *)
			   m = exp'(m', b)
			       (* GDH allows to compute m = exp(m',a) for any m and m', without leaking a *),
      !nbDDH2 ODDHb2(m:G,m':G,j<=nb) := exp'(m, b[j]) = exp'(m',b),
      !nbDDH3 ODDHb3(m:G,m':G,j<=na) := exp'(m, a[j]) = exp'(m',b),
      !nbDDH4 ODDHb4(m:G,j'<=nb,j<=nb) := exp'(m, b[j]) = exp'(g,mult(b[j'],b)),
      !nbDDH5 ODDHb5(m:G,j'<=nb,j<=na) := exp'(m, a[j]) = exp'(g,mult(b[j'],b)),
      !nbDDH6 ODDHb6(m:G,j'<=na,j<=nb) :=
      	      find u<=na suchthat defined(ka[u],a[u]) && a[j'] = a[u] then exp'(m, b[j]) = exp'(g,mult(a[j'],b)) else
	      if defined(kb) then exp'(m, b[j]) = exp'(g,mult(a[j'],b)) else
      	      b[j] = b && m = exp'(g,a[j']),
      !nbDDH7 ODDHb7(m:G,j'<=na,j<=na) :=
      	      find u<=na suchthat defined(ka[u],a[u]) && a[j'] = a[u] then exp'(m, a[j]) = exp'(g,mult(a[j'],b)) else
	      if defined(kb) then exp'(m, a[j]) = exp'(g,mult(a[j'],b)) else
      	      a[j] = a[j'] && m = exp'(g,b),
      !nbDDH ODDHb(m:G, j<=na) := find u<=na suchthat defined(ka[u],a[u]) && a[j] = a[u] then m = exp'(g, mult(a[j], b)) else 
                            if defined(kb) then m = exp'(g, mult(a[j], b)) else false,
      !nbDDH8 ODDHb8(m:G,j<=nb) := m = exp'(g,mult(b[j], b))
    ).

    (* We need to consider both forms m = exp(m', a) and m = exp(g,
    mult(b[j], a)) in the equivalence, because, when m' is known to be
    exp(g, b[j]), CryptoVerif is going to simplify m = exp(m', a) into
    m = exp(g, mult(b[j], a)), and the procedure that tests whether a
    term in the game matches a term in the equivalence would not
    recognize that m = exp(g, mult(b[j], a)) in the game matches m =
    exp(m', a) in the equivalence. *)

}


proba pGDH.
expand GDH_prime_order(elt, key, G, exp, mult, pGDH).

letfun dh_keygen() =
   new x:key;
   (x,exp(G,x)).

param N, N', N'', N2, N3, N4.

(* HKDF_extract_zero_salt, that is, HKDF_extract with salt argument 
   0, is a random oracle. *)

type hashkey [large,fixed].

expand ROM_hash(hashkey, key, extracted, HKDF_extract_zero_salt).

param qH [noninteractive].
channel c1, c2.
let hashoracle = ! qH in(c1, x:key); out(c2, HKDF_extract_zero_salt(hk,x)). 

(* We use the lemma proved in KeySchedule1.cv *)

type two_keys [large,fixed].
fun Derive_Secret_cets_eems(extracted, bitstring): two_keys.
fun Derive_Secret_psk_binder_key(extracted): key.
fun HKDF_extract_DHE(extracted, elt): extracted.

proba Pprf1.

equiv prf1
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cets_eems(k, log),
		              O2() := Derive_Secret_psk_binder_key(k),
			      !N'' O3(DHE: elt) := HKDF_extract_DHE(k, DHE))
     <=(N3 * Pprf1(time + (N3-1)*(time(Derive_Secret_psk_binder_key) + N * time(Derive_Secret_cets_eems, maxlength(log)) + N'' * time(HKDF_extract_DHE)), N, N''))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: two_keys; r,
	    O2() := new r': key; r',
	    !N'' O3(DHE: elt) :=
	        find[unique] j''<=N'' suchthat defined(DHE[j''],r''[j'']) && DHE = DHE[j''] then r''[j''] 
		else new r'': extracted; r'').
       
fun get_client_ets(two_keys): key.
fun get_eets(two_keys): key.

equiv cets_eems
      !N new r: two_keys; (O1() := get_client_ets(r),
      	    	           O2() := get_eets(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2).

(* We use the lemma proved in KeySchedule2.cv *)

fun Derive_Secret_cs_hts(extracted,bitstring):two_keys.
fun HKDF_extract_zero(extracted):extracted.


proba Pprf2.

equiv prf2
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cs_hts(k, log),
		              O2() := HKDF_extract_zero(k))
     <=(N3 * Pprf2(time + (N3-1)*(time(HKDF_extract_zero) + N * time(Derive_Secret_cs_hts, maxlength(log))), N))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: two_keys; r,
	    O2() := new r': extracted; r').

fun get_client_hts(two_keys): key.
fun get_server_hts(two_keys): key.

equiv client_server_hts
      !N new r: two_keys; (O1() := get_client_hts(r),
      	    	           O2() := get_server_hts(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2).

(* We use the lemma proved in KeySchedule3.cv *)

type three_keys [large, fixed].
fun Derive_Secret_cs_ats_exp(extracted, bitstring): three_keys.
fun Derive_Secret_rms(extracted, bitstring): key.

proba Pprf3.

equiv prf3
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cs_ats_exp(k, log),
		              !N' O2(log': bitstring) := Derive_Secret_rms(k, log'))
     <=(N3 * Pprf2(time + (N3-1)*(N' * time(Derive_Secret_rms, maxlength(log')) + N * time(Derive_Secret_cs_ats_exp, maxlength(log))), N, N'))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: three_keys; r,
	    !N' O2(log':bitstring) :=
	        find[unique] j'<=N' suchthat defined(log'[j'],r'[j']) && log' = log'[j'] then r'[j'] 
		else new r': key; r').      

fun get_client_ats(three_keys): key.
fun get_server_ats(three_keys): key.
fun get_exporter_ms(three_keys): key.

equiv client_server_ats_exporter_ms
      !N new r: three_keys; (O1() := get_client_ats(r),
      	    	             O2() := get_server_ats(r),
			     O3() := get_exporter_ms(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2,
	  O3() := new r3: key; r3).

(* We use the lemma proved in HKDFexpand.cv *)

fun HKDF_expand_fin_label(key): key.
fun HKDF_expand_key_label(key): key.
fun HKDF_expand_iv_label(key): key.

proba Pprf_fin_key_iv.

equiv prf_fin_key_iv
      !N3 new r: key; (O1() := HKDF_expand_fin_label(r),
      	      	       O2() := HKDF_expand_key_label(r),
		       O3() := HKDF_expand_iv_label(r))
    <=(N3 * Pprf_fin_key_iv(time + (N3-1)*(time(HKDF_expand_fin_label) + time(HKDF_expand_key_label) + time(HKDF_expand_iv_label))))=>
      !N3 (O1() := new r1: key; r1,
      	   O2() := new r2: key; r2,
	   O3() := new r3: key; r3).

(* SUF-CMA MAC
   The MAC is actually a combination of a hash followed by a MAC.
   It is easy to see that the combination is SUF-CMA provided the MAC is SUF-CMA 
   and the hash is collision resistant. *)

define SUF_CMA_mac_nokgen(mkey, macinput, macres, mac, check, Pmac) {

fun mac(mkey, macinput):macres.
fun check(mkey, macinput, macres): bool.

fun mac2(mkey, macinput):macres.

forall m:macinput, k:mkey;
	check(k, m, mac(k, m)).

forall m:macinput, k:mkey, m':macres;
	(mac(k,m) = m') = check(k, m, m').

equiv suf_cma(mac)
      ! N3 new k: mkey;(
	 !N Omac(x: macinput) := mac(k, x),
	 !N2 Ocheck(m: macinput, ma: macres) := check(k, m, ma))
     <=(N3 * Pmac(time + (N3-1)*(N*time(mac,maxlength(x)) + N2*time(check,maxlength(m),maxlength(ma))), N, N2, max(maxlength(x), maxlength(m))))=> [computational]
      ! N3 new k: mkey [unchanged];(
	 !N Omac(x: macinput) := let ma2:macres = mac2(k, x) in ma2,
	 !N2 Ocheck(m: macinput, ma: macres) := 
	    find j <= N suchthat defined(x[j], ma2[j]) && (m = x[j]) && ma = ma2[j] then true else false).

}

proba Pmac.
expand SUF_CMA_mac_nokgen(key, bitstring, bitstring, mac, check, Pmac).

(* Message formats *)

type nonce [large, fixed].
type certificate.

fun ClientHelloOut(nonce, elt, bitstring): bitstring [compos].
fun ClientHelloIn(nonce, elt, bitstring, bitstring, bitstring): bitstring [compos].
fun ServerHelloIn(nonce, elt, bitstring): bitstring [compos].
fun ServerHelloOut(nonce, elt): bitstring [compos].
fun ServerFinishedIn(bitstring,bitstring): bitstring [compos].
fun ServerFinishedOut(bitstring): bitstring [compos].

fun ClientFinishedOut(bitstring): bitstring  [compos].
fun ClientFinishedIn(bitstring,bitstring): bitstring  [compos].

(* Logs *)

fun ClientHelloBinderLogInfo(nonce,elt,bitstring): bitstring [compos].
fun ClientHelloLogInfo(bitstring,bitstring,bitstring): bitstring [compos].
fun ServerHelloLogInfo(bitstring,nonce,elt,bitstring): bitstring [compos].
fun ServerBeforeFinishedLogInfo(bitstring,bitstring): bitstring [compos].
fun ServerFinishedLogInfo(bitstring,bitstring): bitstring [compos].
fun ClientBeforeFinishedLogInfo(bitstring, bitstring): bitstring [compos].
fun ClientFinishedLogInfo(bitstring, bitstring): bitstring [compos].

(* Secrecy of the key *)

query secret client_ts0_secret_c.
query secret server_ts0_secret_c.
query secret client_ts0_secret_s.
query secret server_ts0_secret_s.

(* Authentication of the server to the client *)

event ClientTerm(nonce,elt,bitstring,bitstring,bitstring,nonce,elt,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key).
event ServerAccept(nonce,elt,bitstring,bitstring,bitstring,nonce,elt,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key).

query cr: nonce, gx: elt, log1: bitstring, binder: bitstring, log1': bitstring, sr: nonce, gy: elt, log2: bitstring, log3: bitstring, m: bitstring,
      client_hk: key, server_hk: key, client_hiv: key, server_hiv: key, cfk: key, sfk: key, client_ts0: key, server_ts0: key;
      event inj:ClientTerm(cr,gx,log1,binder,log1',sr,gy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0) ==>
      	    inj:ServerAccept(cr,gx,log1,binder,log1',sr,gy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0).

(* Authentication of the client to the server *)

event ServerTerm(nonce,elt,bitstring,bitstring,bitstring,nonce,elt,bitstring,bitstring,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key,key).
event ClientAccept(nonce,elt,bitstring,bitstring,bitstring,nonce,elt,bitstring,bitstring,bitstring,bitstring,bitstring,key,key,key,key,key,key,key,key,key).

query cr: nonce, gx: elt, log1: bitstring, binder: bitstring, log1': bitstring, sr: nonce, gy: elt, log2: bitstring,
      log3: bitstring, m: bitstring, log4: bitstring, cfin: bitstring, client_hk: key, server_hk: key,
      client_hiv: key, server_hiv: key, cfk: key, sfk: key, client_ts0: key, server_ts0: key,
      res_secret: key;
      event inj:ServerTerm(cr,gx,log1,binder,log1',sr,gy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,res_secret) ==>
      	    inj:ClientAccept(cr,gx,log1,binder,log1',sr,gy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,res_secret).


letfun send_client_hello1() = 
   new cr:nonce;
   new x:key;
   let gx = exp(G,x) in
   (cr,x,gx).

letfun send_client_hello2(earlySecret: extracted, binder_key: key, cr: nonce, x:key, gx: elt, log1: bitstring, log1': bitstring) = 
   let chbl = ClientHelloBinderLogInfo(cr,gx,log1) in
   let binder = mac(binder_key, chbl) in
   let chl = ClientHelloLogInfo(chbl, binder, log1') in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   let client_ets = get_client_ets(cets_eems) in
   (cr,x,gx, binder, chl, client_ets).


letfun recv_server_hello(earlySecret: extracted, sil:bitstring, x:key) = 
  let ServerHelloLogInfo(chl,sr,gy,l2) = sil in
  (let s = exp(gy,x) in
   let handshakeSecret = HKDF_extract_DHE(earlySecret, s) in
   let cs_hts = Derive_Secret_cs_hts(handshakeSecret,sil) in
   let client_hts = get_client_hts(cs_hts) in
   let server_hts = get_server_hts(cs_hts) in
   let client_hk = HKDF_expand_key_label(client_hts) in
   let server_hk = HKDF_expand_key_label(server_hts) in
   let client_hiv = HKDF_expand_iv_label(client_hts) in
   let server_hiv = HKDF_expand_iv_label(server_hts) in
   let cfk = HKDF_expand_fin_label(client_hts) in
   let sfk = HKDF_expand_fin_label(server_hts) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (masterSecret,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,true))
  else (zero_extracted,zero_key,zero_key,zero_key,zero_key,zero_key,zero_key,false).
   

letfun recv_server_finished(sil:bitstring, masterSecret:extracted, sfk: key,
       		            m:bitstring, 
			    log3:bitstring) =
   let scvl = ServerBeforeFinishedLogInfo(sil, log3) in
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let cs_ats_exp = Derive_Secret_cs_ats_exp(masterSecret,sfl) in
   let client_ts0 = get_client_ats(cs_ats_exp) in
   let server_ts0 = get_server_ats(cs_ats_exp) in
   (client_ts0,server_ts0, mac(sfk,scvl) = m).
			   
letfun send_client_finished(log:bitstring, cfk:key) = 
   mac(cfk,log).

letfun get_resumption_secret(masterSecret: extracted, cfl: bitstring) =
   Derive_Secret_rms(masterSecret, cfl).

letfun recv_client_hello(earlySecret: extracted, binder_key: key, cr:nonce, gx:elt, log1: bitstring, binder: bitstring, log1': bitstring) = 
   let chbl = ClientHelloBinderLogInfo(cr,gx,log1) in
   if mac(binder_key, chbl) = binder then
   (
   let chl = ClientHelloLogInfo(chbl, binder, log1') in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   let client_ets = get_client_ets(cets_eems) in
   new sr:nonce;
   new y: key;
   let gy = exp(G,y) in
   let s = exp(gx,y) in
   let handshakeSecret = HKDF_extract_DHE(earlySecret,s) in   
   (sr,gy,handshakeSecret,chl,client_ets,true)
   )
   else
   (cr,gx,zero_extracted,chbl,zero_key,false).

letfun onertt_hs_keys(sil:bitstring,handshakeSecret:extracted) = 
   let cs_hts = Derive_Secret_cs_hts(handshakeSecret,sil) in
   let client_hts = get_client_hts(cs_hts) in
   let server_hts = get_server_hts(cs_hts) in
   let client_hk = HKDF_expand_key_label(client_hts) in
   let server_hk = HKDF_expand_key_label(server_hts) in
   let client_hiv = HKDF_expand_iv_label(client_hts) in
   let server_hiv = HKDF_expand_iv_label(server_hts) in
   let cfk = HKDF_expand_fin_label(client_hts) in
   let sfk = HKDF_expand_fin_label(server_hts) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (client_hk, server_hk, client_hiv, server_hiv, cfk, sfk, masterSecret).

letfun send_server_finished(scvl:bitstring,sfk:key) = 
   mac(sfk,scvl).

letfun onertt_data_keys(masterSecret: extracted, sfl:bitstring) = 
   let cs_ats_exp = Derive_Secret_cs_ats_exp(masterSecret,sfl) in
   let client_ts0 = get_client_ats(cs_ats_exp) in
   let server_ts0 = get_server_ats(cs_ats_exp) in
   (client_ts0, server_ts0).

letfun check_client_finished(masterSecret: extracted, ccvl:bitstring,cfin:bitstring,cfk:key) = 
   if mac(cfk,ccvl) = cfin then
   (
       let cfl = ClientFinishedLogInfo(ccvl, cfin) in
       let resumption_secret = Derive_Secret_rms(masterSecret, cfl) in
       (resumption_secret, true)
   )
   else
       (zero_key, false).


param N1,N5,N6,
      N7,N8,N9,N10,N11,N12,
      N13,N14,N15,N16.

let Client = 
!N1
    in(io1,log1: bitstring);
    let (cr: nonce,  x: key, gx: elt) = send_client_hello1() in
    out(io1', (cr,gx));
    (* Give cr,gx to the adversary, so that it can compute binders for
       other PSKs (in log1') and add them to the ClientHello message *) 
    in(io2', log1': bitstring);
    let (cr:nonce,x:key,cgx:elt, binder: bitstring, chl: bitstring, client_ets: key) = send_client_hello2(earlySecret, binder_key, cr, x, gx, log1, log1') in
    (* for 0-rtt  insert clientEphemeralKeys(cr,x,cgx); *)
    out(io2,(ClientHelloOut(cr,cgx,binder), client_ets));
    in(io3,ServerHelloIn(sr,cgy,log2));
    let sil = ServerHelloLogInfo(chl,sr,cgy,log2) in
    let (masterSecret:extracted,client_hk:key,server_hk:key,client_hiv:key,server_hiv:key,cfk:key,sfk:key,=true) = recv_server_hello(earlySecret,sil,x) in
    out(io4,(client_hk, server_hk, client_hiv, server_hiv));
    in(io5,(ServerFinishedIn(log3,m), ClientAuth: bool, log4: bitstring)); 
    let (client_ts0:key,server_ts0:key,=true) = recv_server_finished(sil,masterSecret,sfk,m,log3) in   
    let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
    let c_sfl : bitstring = ServerFinishedLogInfo(scvl,m) in
    let ccvl = ClientBeforeFinishedLogInfo(c_sfl,log4) in
    let cfin = send_client_finished(ccvl,cfk) in
    let cfl = ClientFinishedLogInfo(ccvl, cfin) in
    let resumption_secret = get_resumption_secret(masterSecret, cfl) in
    event ClientAccept(cr,cgx,log1,binder,log1',sr,cgy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,resumption_secret);
    out(io6,ClientFinishedOut(cfin));
    in(io7,());
    (* The client is talking to the honest server.
       Check that the shared key is secret. *)
    event ClientTerm(cr,cgx,log1,binder,log1',sr,cgy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0);
    let client_ts0_secret_c: key = client_ts0 in
    let server_ts0_secret_c: key = server_ts0 in
    out(io8, resumption_secret).

let Server = 
 !N6
   in(io9,ClientHelloIn(cr,sgx,log1,binder,log1'));
   let (sr:nonce,sgy:elt,handshakeSecret:extracted, chl: bitstring, client_ets: key,=true) = recv_client_hello(earlySecret,binder_key,cr,sgx,log1,binder,log1') in
   out(io10,(ServerHelloOut(sr,sgy), client_ets));
   in(io11,log2:bitstring);
   let sil = ServerHelloLogInfo(chl,sr,sgy,log2) in
   let (client_hk:key, server_hk: key, client_hiv: key, server_hiv: key, cfk: key, sfk: key, masterSecret: extracted) = onertt_hs_keys(sil,handshakeSecret) in
   out(io12,(client_hk, server_hk, client_hiv, server_hiv));
   in(io13,log3:bitstring);
   let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
   let m = send_server_finished(scvl,sfk) in
   let s_sfl = ServerFinishedLogInfo(scvl,m) in
   let (client_ts0: key, server_ts0: key) = onertt_data_keys(masterSecret,s_sfl) in
   event ServerAccept(cr,sgx,log1,binder,log1',sr,sgy,log2,log3,m,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0);
   out(io18,ServerFinishedOut(m));
   in(io19,ClientFinishedIn(log4, cfin));
   let ccvl = ClientBeforeFinishedLogInfo(s_sfl,log4) in
   let (resumption_secret: key, =true) = check_client_finished(masterSecret,ccvl,cfin,cfk) in
   event ServerTerm(cr,sgx,log1,binder,log1',sr,sgy,log2,log3,m,log4,cfin,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,client_ts0,server_ts0,resumption_secret);
   (* By the correspondence ServerTermAuth ==> ClientAcceptAuth, the client has the same key.
      The secrecy of the traffic secrets client_ts0, server_ts0 is proved at the client. *)
   let client_ts0_secret_s: key = client_ts0 in
   let server_ts0_secret_s: key = server_ts0 in
   out(io30, resumption_secret).

process 
  in(io20,());
  new hk: hashkey; (* Key that models the choice of the random oracle *)
  new PSK: key;
  let earlySecret = HKDF_extract_zero_salt(hk, PSK) in
  let binder_key = Derive_Secret_psk_binder_key(earlySecret) in
  out(io21,());
  (Client | Server | hashoracle)
