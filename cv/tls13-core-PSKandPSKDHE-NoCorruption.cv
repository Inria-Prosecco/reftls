(* This file proves properties of the handshake with pre-shared key.
It proves secrecy, authentication, and unique channel identifier
properties.
Secrecy is proved both on the client side and on the server side.
On the server side, secrecy of sats is proved
when the server sends the ServerFinished message, before it
receives the ClientFinished message. This property is useful for
proving security of 0.5RTT messages, by composition with the record
protocol. *)


channel io1, io1', io2, io2', io3, io4, io5, io6, io7, io8, io9, io10,
	io11, io12, io13, io14, io15, io16, io17, io18, io19, io20,
	io11', io12', io13', io14', 
	io21, io22, io23, io24, io25, io26, io27, io28, io29, io30,
	dhe_io1, dhe_io1', dhe_io2, dhe_io2', dhe_io3, dhe_io4, dhe_io5, dhe_io6, dhe_io7, dhe_io8, dhe_io9, dhe_io10,
	dhe_io11, dhe_io12, dhe_io13, dhe_io14, dhe_io15, dhe_io16, dhe_io17, dhe_io18, dhe_io19, dhe_io20,
	dhe_io11', dhe_io12', dhe_io13', dhe_io14', 
	dhe_io21, dhe_io22, dhe_io23, dhe_io24, dhe_io25, dhe_io26, dhe_io27, dhe_io28, dhe_io29, dhe_io30,
	cCorrupt.

param N1,N5,N6,
      N7,N8,N9,N10,N11,N12,
      N13,N14,N15,N16.

(* The proof can be guided as follows, but the automatic proof strategy works.

proof {
      crypto rom(HKDF_extract_zero_salt);
      crypto prf1;
      crypto suf_cma(mac) *;
      crypto prf2 *;
      crypto client_server_hts *;
      crypto prf_fin_key_iv *;
      crypto prf3 *;
      crypto suf_cma(mac) *; 
      auto
}
*)


type key [large, fixed].
const zero_key: key.
type extracted [large, fixed].
const zero_extracted: extracted. 

type elt [large, bounded].
fun element2key(elt): key [compos].
fun elt2bitstring(elt): bitstring [compos].

(* Gap Diffie-Hellman assumption.
   The considered groups are prime order. *)

proba pGDH.
expand GDH_prime_order(elt, key, G, exp, mult, pGDH).

letfun dh_keygen() =
   new x:key;
   (x,exp(G,x)).

param N, N', N'', N2, N3, N4.

(* HKDF_extract_zero_salt, that is, HKDF_extract with salt argument 
   0, is a random oracle. *)

type hashkey [large,fixed].

expand ROM_hash(hashkey, key, extracted, HKDF_extract_zero_salt).

param qH [noninteractive].
channel ch3, ch4.
let hashoracle = ! qH in(ch3, x:key); out(ch4, HKDF_extract_zero_salt(hk,x)). 

(* We use the lemma proved in KeySchedule1.cv *)

type two_keys [large,fixed].
const zero_two_keys: two_keys.
fun Derive_Secret_cets_eems(extracted, bitstring): two_keys.
fun Derive_Secret_psk_binder_key(extracted): key.
fun HKDF_extract_DHE(extracted, elt): extracted.
fun HKDF_extract_zero1(extracted): extracted.

proba Pprf1.

equiv prf1
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cets_eems(k, log),
		              O2() := Derive_Secret_psk_binder_key(k),
			      !N'' O3(DHE: elt) := HKDF_extract_DHE(k, DHE),
			      O4() := HKDF_extract_zero1(k))
     <=(N3 * Pprf1(time + (N3-1)*(time(Derive_Secret_psk_binder_key) + N * time(Derive_Secret_cets_eems, maxlength(log)) + N'' * time(HKDF_extract_DHE) + time(HKDF_extract_zero1)), N, N''))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: two_keys; r,
	    O2() := new r': key; r',
	    !N'' O3(DHE: elt) :=
	        find[unique] j''<=N'' suchthat defined(DHE[j''],r''[j'']) && DHE = DHE[j''] then r''[j''] 
		else new r'': extracted; r'',
      	    O4() := new r''': extracted; r''').

fun get_client_ets(two_keys): key.
fun get_eems(two_keys): key.

equiv cets_eems
      !N new r: two_keys; (O1() := get_client_ets(r),
      	    	           O2() := get_eems(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2).

(* We use the lemma proved in KeySchedule2.cv *)

fun Derive_Secret_cs_hts(extracted,bitstring):two_keys.
fun HKDF_extract_zero(extracted):extracted.


proba Pprf2.

equiv prf2
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cs_hts(k, log),
		              O2() := HKDF_extract_zero(k))
     <=(N3 * Pprf2(time + (N3-1)*(time(HKDF_extract_zero) + N * time(Derive_Secret_cs_hts, maxlength(log))), N))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: two_keys; r,
	    O2() := new r': extracted; r').

fun get_client_hts(two_keys): key.
fun get_server_hts(two_keys): key.

equiv client_server_hts
      !N new r: two_keys; (O1() := get_client_hts(r),
      	    	           O2() := get_server_hts(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2).

(* We use the lemma proved in KeySchedule3.cv *)

type three_keys [large, fixed].
fun Derive_Secret_cs_ats_exp(extracted, bitstring): three_keys.
fun Derive_Secret_rms(extracted, bitstring): key.

proba Pprf3.

equiv prf3
       !N3 new k: extracted; (!N O1(log:bitstring) := Derive_Secret_cs_ats_exp(k, log),
		              !N' O2(log': bitstring) := Derive_Secret_rms(k, log'))
     <=(N3 * Pprf2(time + (N3-1)*(N' * time(Derive_Secret_rms, maxlength(log')) + N * time(Derive_Secret_cs_ats_exp, maxlength(log))), N, N'))=>
       !N3 (!N O1(log:bitstring) :=
	        find[unique] j<=N suchthat defined(log[j],r[j]) && log = log[j] then r[j] 
		else new r: three_keys; r,
	    !N' O2(log':bitstring) :=
	        find[unique] j'<=N' suchthat defined(log'[j'],r'[j']) && log' = log'[j'] then r'[j'] 
		else new r': key; r').      

fun get_client_ats(three_keys): key.
fun get_server_ats(three_keys): key.
fun get_exporter_ms(three_keys): key.

equiv client_server_ats_exporter_ms
      !N new r: three_keys; (O1() := get_client_ats(r),
      	    	             O2() := get_server_ats(r),
			     O3() := get_exporter_ms(r))
    <=(0)=>
      !N (O1() := new r1: key; r1,
      	  O2() := new r2: key; r2,
	  O3() := new r3: key; r3).

(* We use the lemma proved in HKDFexpand.cv *)

fun HKDF_expand_fin_label(key): key.
fun HKDF_expand_key_label(key): key.
fun HKDF_expand_iv_label(key): key.

proba Pprf_fin_key_iv.

equiv prf_fin_key_iv
      !N3 new r: key; (O1() := HKDF_expand_fin_label(r),
      	      	       O2() := HKDF_expand_key_label(r),
		       O3() := HKDF_expand_iv_label(r))
    <=(N3 * Pprf_fin_key_iv(time + (N3-1)*(time(HKDF_expand_fin_label) + time(HKDF_expand_key_label) + time(HKDF_expand_iv_label))))=>
      !N3 (O1() := new r1: key; r1,
      	   O2() := new r2: key; r2,
	   O3() := new r3: key; r3).

(* SUF-CMA MAC
   The MAC is actually a combination of a hash followed by a MAC.
   It is easy to see that the combination is SUF-CMA provided the MAC is SUF-CMA 
   and the hash is collision resistant. *)

proba Pmac.
expand SUF_CMA_mac_nokgen(key, bitstring, bitstring, mac, check, Pmac).

(* Message formats *)

type nonce [large, fixed].
type certificate.

fun ClientHelloOut(nonce,bitstring): bitstring [compos].
fun ClientHelloIn(nonce,bitstring,bitstring,bitstring): bitstring [compos].
fun ServerHelloIn(nonce,bitstring): bitstring [compos].
fun ServerHelloOut(nonce): bitstring [compos].

fun ClientHelloOutDHE(nonce, elt, bitstring): bitstring [compos].
fun ClientHelloInDHE(nonce, elt, bitstring, bitstring, bitstring): bitstring [compos].
fun ServerHelloInDHE(nonce, elt, bitstring): bitstring [compos].
fun ServerHelloOutDHE(nonce, elt): bitstring [compos].

fun ServerFinishedIn(bitstring,bitstring): bitstring [compos].
fun ServerFinishedOut(bitstring): bitstring [compos].

fun ClientFinishedOut(bitstring): bitstring  [compos].
fun ClientFinishedIn(bitstring,bitstring): bitstring  [compos].

(* Logs *)

fun ClientHelloBinderLogInfo(nonce,bitstring): bitstring [compos].
fun ClientHelloBinderLogInfoDHE(nonce,elt,bitstring): bitstring [compos].
fun ClientHelloLogInfo(bitstring,bitstring,bitstring): bitstring [compos].
fun ServerHelloLogInfo(bitstring,nonce,bitstring): bitstring [compos].
fun ServerHelloLogInfoDHE(bitstring,nonce,elt,bitstring): bitstring [compos].
fun ServerBeforeFinishedLogInfo(bitstring,bitstring): bitstring [compos].
fun ServerFinishedLogInfo(bitstring,bitstring): bitstring [compos].
fun ClientBeforeFinishedLogInfo(bitstring, bitstring): bitstring [compos].
fun ClientFinishedLogInfo(bitstring, bitstring): bitstring [compos].

forall cr: nonce, l: bitstring, cr': nonce, gx: elt, l': bitstring;
       ClientHelloBinderLogInfo(cr,l) <> ClientHelloBinderLogInfoDHE(cr',gx,l').

(* Tables *)

table c_table(nonce, bitstring, bitstring, bitstring).
table cdhe_table(nonce, elt, bitstring, bitstring, bitstring).

(* Secrecy of the key *)

query secret c_cats public_vars c_sats, c_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret c_sats public_vars c_cats, c_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret c_ems public_vars c_cats, c_sats, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.

query secret s_cats public_vars s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret s_sats public_vars s_cats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret s_ems public_vars s_cats, s_sats, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.

query secret cdhe_cats public_vars cdhe_sats, cdhe_ems, c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret cdhe_sats public_vars cdhe_cats, cdhe_ems, c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret cdhe_ems public_vars cdhe_cats, cdhe_sats, c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.

query secret sdhe_cats public_vars sdhe_sats, sdhe_ems, c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret sdhe_sats public_vars sdhe_cats, sdhe_ems, c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret sdhe_ems public_vars sdhe_cats, sdhe_sats, c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.

query secret c_resumption_secret public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret s_resumption_secret public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, cdhe_resumption_secret, sdhe_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret cdhe_resumption_secret public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.
query secret sdhe_resumption_secret public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, c_cets, c_eems, s_cets2, s_cets3, s_eems, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.

(* Authentication of the server to the client *)

event ClientTerm(bitstring,bitstring).
event ServerAccept(bitstring,bitstring,N6).

query log4: bitstring, keys: bitstring, i<=N6;
      event inj:ClientTerm(log4, keys) ==> inj:ServerAccept(log4, keys, i).

query log4: bitstring, s_keys: bitstring, s_keys': bitstring, i <= N6, i' <= N6;
      event ServerAccept(log4, s_keys, i) &&
      	    ServerAccept(log4, s_keys', i') ==>
	    i = i'.

event ClientTermDHE(bitstring,bitstring).
event ServerAcceptDHE(bitstring,bitstring, N7).

query log4: bitstring, keys: bitstring, i <= N7;
      event inj:ClientTermDHE(log4, keys) ==> inj:ServerAcceptDHE(log4, keys, i).

query log4: bitstring, s_keys: bitstring, s_keys': bitstring, i <= N7, i' <= N7;
      event ServerAcceptDHE(log4, s_keys, i) &&
      	    ServerAcceptDHE(log4, s_keys', i') ==>
	    i = i'.

(* Authentication of the client to the server *)

event ServerTerm(bitstring,bitstring).
event ClientAccept(bitstring,bitstring, N1).

query log7: bitstring, keys: bitstring, i <= N1;
      event inj:ServerTerm(log7, keys) ==> inj:ClientAccept(log7, keys, i).

query log7: bitstring, c_keys: bitstring, c_keys': bitstring, i <= N1, i' <= N1;
      event ClientAccept(log7, c_keys, i) &&
      	    ClientAccept(log7, c_keys', i') ==>
	    i = i'.

event ServerTermDHE(bitstring,bitstring).
event ClientAcceptDHE(bitstring,bitstring, N2).

query log7: bitstring, keys: bitstring, i <= N2;
      event inj:ServerTermDHE(log7, keys) ==> inj:ClientAcceptDHE(log7, keys, i).

query log7: bitstring, c_keys: bitstring, c_keys': bitstring, i <= N2, i' <= N2;
      event ClientAcceptDHE(log7, c_keys, i) &&
      	    ClientAcceptDHE(log7, c_keys', i') ==>
	    i = i'.

(* Early authentication - these are limited authentication properties
   guaranteed by the MAC *)

event ServerEarlyTerm(nonce,bitstring,bitstring).
event ClientEarlyAccept(nonce,bitstring,bitstring).

query cr: nonce, log1: bitstring, binder: bitstring;
      event ServerEarlyTerm(cr, log1, binder) ==>
      	    ClientEarlyAccept(cr, log1, binder).

event ServerEarlyTermDHE(nonce,elt,bitstring,bitstring).
event ClientEarlyAcceptDHE(nonce,elt,bitstring,bitstring).

query cr: nonce, gx: elt, log1: bitstring, binder: bitstring;
      event ServerEarlyTermDHE(cr, gx, log1, binder) ==>
      	    ClientEarlyAcceptDHE(cr, gx, log1, binder).

(* We cannot prove injectivity because of the replay attack.
   We cannot prove that log1' is the same on the client and server sides
   (because it is not included in the MAC).
   As a result, the early keys cets and eems may also be different on the 
   client and server sides. *)

(* Properties for 0-RTT for the PSK handshake
   We focus on cets. We could prove similar properties for eems *)

(* Case in which messages are not altered *) 
event ServerEarlyTerm1(bitstring,key).
event ClientEarlyAccept1(bitstring,key,N1).

query log1: bitstring, cets: key, i <= N1;
      event ServerEarlyTerm1(log1, cets) ==>
      	    ClientEarlyAccept1(log1, cets, i).

query log1: bitstring, cets: key, cets': key, i <= N1, i' <= N1;
      event ClientEarlyAccept1(log1, cets, i) &&
      	    ClientEarlyAccept1(log1, cets', i') ==> i = i'.

query secret c_cets public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_eems, s_eems, s_cets3, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems.


(* Case in which messages are altered *) 
event ServerEarlyTerm2(bitstring,key).

query log1: bitstring, cets: key, cets': key;
      event ServerEarlyTerm2(log1, cets) &&
      	    ServerEarlyTerm2(log1, cets') ==> cets = cets'.

query secret s_cets1 public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, cdhe_cets, cdhe_eems, sdhe_cets2, sdhe_cets3, sdhe_eems, c_eems, s_eems, c_cets.

(* Properties for 0-RTT for the PSKDHE handshake
   We focus on cets. We could prove similar properties for eems *)

(* Case in which messages are not altered *) 
event ServerEarlyTermDHE1(bitstring,key).
event ClientEarlyAcceptDHE1(bitstring,key,N2).

query log1: bitstring, cets: key, i2 <= N2;
      event ServerEarlyTermDHE1(log1, cets) ==>
      	    ClientEarlyAcceptDHE1(log1, cets,i2).

query log1: bitstring, cets: key, cets': key, i <= N2, i' <= N2;
      event ClientEarlyAcceptDHE1(log1, cets, i) &&
      	    ClientEarlyAcceptDHE1(log1, cets', i') ==> i = i'.

query secret cdhe_cets public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_eems, c_cets, s_eems, s_cets2, s_cets3, cdhe_eems, sdhe_eems, sdhe_cets3.


(* Case in which messages are altered *) 
event ServerEarlyTermDHE2(bitstring,key).

query log1: bitstring, cets: key, cets': key;
      event ServerEarlyTermDHE2(log1, cets) &&
      	    ServerEarlyTermDHE2(log1, cets') ==> cets = cets'.

query secret sdhe_cets1 public_vars c_cats, c_sats, c_ems, s_cats, s_sats, s_ems, cdhe_cats, cdhe_sats, cdhe_ems, sdhe_cats, sdhe_sats, sdhe_ems, c_resumption_secret, s_resumption_secret, cdhe_resumption_secret, sdhe_resumption_secret, c_eems, c_cets, s_eems, s_cets2, s_cets3, cdhe_eems, sdhe_eems, cdhe_cets.


(* Unique channel identifier *)

event ClientTerm1(bitstring, bitstring, bitstring).
event ServerTerm1(bitstring, bitstring, bitstring).

query sfl: bitstring, c_cfl: bitstring, s_cfl: bitstring, c_keys: bitstring, s_keys: bitstring;
      event ClientTerm1(sfl, c_cfl, c_keys) && ServerTerm1(sfl, s_cfl, s_keys) ==>
      c_cfl = s_cfl && c_keys = s_keys.


letfun send_client_hello1() = 
   new cr:nonce;
   cr.

letfun send_client_hello2(earlySecret: extracted, binder_key: key, cr: nonce, log1: bitstring, log1': bitstring) =
   let chbl = ClientHelloBinderLogInfo(cr,log1) in
   let binder = mac(binder_key, chbl) in
   let chl = ClientHelloLogInfo(chbl, binder, log1') in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   (cr, binder, chl, cets_eems).

letfun recv_server_hello(handshakeSecret: extracted, sil:bitstring) = 
  let ServerHelloLogInfo(chl,sr,l2) = sil in
  (let cs_hts = Derive_Secret_cs_hts(handshakeSecret,sil) in
   let client_hts = get_client_hts(cs_hts) in
   let server_hts = get_server_hts(cs_hts) in
   let client_hk = HKDF_expand_key_label(client_hts) in
   let server_hk = HKDF_expand_key_label(server_hts) in
   let client_hiv = HKDF_expand_iv_label(client_hts) in
   let server_hiv = HKDF_expand_iv_label(server_hts) in
   let cfk = HKDF_expand_fin_label(client_hts) in
   let sfk = HKDF_expand_fin_label(server_hts) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (masterSecret,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,true))
  else (zero_extracted,zero_key,zero_key,zero_key,zero_key,zero_key,zero_key,false).
   

letfun recv_server_finished(sil:bitstring, masterSecret:extracted, sfk: key,
       		            m:bitstring, 
			    log3:bitstring) =
   let scvl = ServerBeforeFinishedLogInfo(sil, log3) in
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let cs_ats_exp = Derive_Secret_cs_ats_exp(masterSecret,sfl) in
   (cs_ats_exp, mac(sfk,scvl) = m).
			   
letfun send_client_finished(log:bitstring, cfk:key) = 
   mac(cfk,log).

letfun get_resumption_secret(masterSecret: extracted, cfl: bitstring) =
   Derive_Secret_rms(masterSecret, cfl).

letfun recv_client_hello(earlySecret: extracted, binder_key: key, cr:nonce, log1: bitstring, binder: bitstring, log1': bitstring) = 
   let chbl = ClientHelloBinderLogInfo(cr,log1) in
   if mac(binder_key, chbl) = binder then
   (
   let chl = ClientHelloLogInfo(chbl, binder, log1') in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   new sr:nonce;
   (sr,chl,cets_eems,true)
   )
   else
   (cr,chbl,zero_two_keys,false).

letfun onertt_hs_keys(sil:bitstring,handshakeSecret:extracted) = 
   let cs_hts = Derive_Secret_cs_hts(handshakeSecret,sil) in
   let client_hts = get_client_hts(cs_hts) in
   let server_hts = get_server_hts(cs_hts) in
   let client_hk = HKDF_expand_key_label(client_hts) in
   let server_hk = HKDF_expand_key_label(server_hts) in
   let client_hiv = HKDF_expand_iv_label(client_hts) in
   let server_hiv = HKDF_expand_iv_label(server_hts) in
   let cfk = HKDF_expand_fin_label(client_hts) in
   let sfk = HKDF_expand_fin_label(server_hts) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (client_hk, server_hk, client_hiv, server_hiv, cfk, sfk, masterSecret).

letfun send_server_finished(scvl:bitstring,sfk:key) = 
   mac(sfk,scvl).

letfun onertt_data_keys(masterSecret: extracted, sfl:bitstring) = 
   Derive_Secret_cs_ats_exp(masterSecret,sfl).

letfun check_client_finished(masterSecret: extracted, ccvl:bitstring,cfin:bitstring,cfk:key) = 
   if mac(cfk,ccvl) = cfin then
   (
       let cfl = ClientFinishedLogInfo(ccvl, cfin) in
       let resumption_secret = Derive_Secret_rms(masterSecret, cfl) in
       (resumption_secret, true)
   )
   else
       (zero_key, false).

(* Functions modified for the version with DHE *)

letfun send_client_hello1DHE() = 
   new cr:nonce;
   new x:key;
   let gx = exp(G,x) in
   (cr,x,gx).

letfun send_client_hello2DHE(earlySecret: extracted, binder_key: key, cr: nonce, x:key, gx: elt, log1: bitstring, log1': bitstring) = 
   let chbl = ClientHelloBinderLogInfoDHE(cr,gx,log1) in
   let binder = mac(binder_key, chbl) in
   let chl = ClientHelloLogInfo(chbl, binder, log1') in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   (cr,x,gx, binder, chl, cets_eems).

letfun recv_server_helloDHE(earlySecret: extracted, sil:bitstring, x:key) = 
  let ServerHelloLogInfoDHE(chl,sr,gy,l2) = sil in
  (let s = exp(gy,x) in
   let handshakeSecret = HKDF_extract_DHE(earlySecret, s) in
   let cs_hts = Derive_Secret_cs_hts(handshakeSecret,sil) in
   let client_hts = get_client_hts(cs_hts) in
   let server_hts = get_server_hts(cs_hts) in
   let client_hk = HKDF_expand_key_label(client_hts) in
   let server_hk = HKDF_expand_key_label(server_hts) in
   let client_hiv = HKDF_expand_iv_label(client_hts) in
   let server_hiv = HKDF_expand_iv_label(server_hts) in
   let cfk = HKDF_expand_fin_label(client_hts) in
   let sfk = HKDF_expand_fin_label(server_hts) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (masterSecret,client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,true))
  else (zero_extracted,zero_key,zero_key,zero_key,zero_key,zero_key,zero_key,false).

letfun recv_client_helloDHE(earlySecret: extracted, binder_key: key, cr:nonce, gx:elt, log1: bitstring, binder: bitstring, log1': bitstring) = 
   let chbl = ClientHelloBinderLogInfoDHE(cr,gx,log1) in
   if mac(binder_key, chbl) = binder then
   (
   let chl = ClientHelloLogInfo(chbl, binder, log1') in
   let cets_eems = Derive_Secret_cets_eems(earlySecret, chl) in
   new sr:nonce;
   new y: key;
   let gy = exp(G,y) in
   let s = exp(gx,y) in
   let handshakeSecret = HKDF_extract_DHE(earlySecret,s) in   
   (sr,gy,handshakeSecret,chl,cets_eems,true)
   )
   else
   (cr,gx,zero_extracted,chbl,zero_two_keys,false).



(* PSK without DHE *)

let Client = 
!i1 <= N1
    in(io1,c_log1: bitstring);
    let cr = send_client_hello1() in
    out(io1', cr);
    (* Give cr to the adversary, so that it can compute binders for
       other PSKs (in c_log1') and add them to the ClientHello message *) 
    in(io2', c_log1': bitstring);
    let (c_cr:nonce,c_binder: bitstring, chl: bitstring,cets_eems: two_keys) = send_client_hello2(earlySecret, binder_key, cr, c_log1, c_log1') in
    let cets = get_client_ets(cets_eems) in
    let c_eems: key = get_eems(cets_eems) in
    event ClientEarlyAccept(c_cr, c_log1, c_binder);
    insert c_table(c_cr, c_log1, c_binder, c_log1'); 
    (* 0-RTT: We compose with tls13-core-RecordProtocol-0RTT.cv, 
       with secret c_cets
       (ClientEarlyAccept1 is event e1 - non-injective variant). *)
    event ClientEarlyAccept1((c_cr, c_log1, c_binder, c_log1'), cets, i1);
    let c_cets: key = cets in
    out(io2,ClientHelloOut(c_cr, c_binder));
    in(io3,ServerHelloIn(sr,log2));
    let sil = ServerHelloLogInfo(chl,sr,log2) in
    let (masterSecret:extracted,client_hk:key,server_hk:key,client_hiv:key,server_hiv:key,cfk:key,sfk:key,=true) = recv_server_hello(handshakeSecret,sil) in
    out(io4,(client_hk, server_hk, client_hiv, server_hiv));
    in(io5,(ServerFinishedIn(log3,m), ClientAuth: bool, log4: bitstring)); 
    let (cs_ats_exp:three_keys,=true) = recv_server_finished(sil,masterSecret,sfk,m,log3) in   
    let cats = get_client_ats(cs_ats_exp) in
    let sats = get_server_ats(cs_ats_exp) in
    let ems = get_exporter_ms(cs_ats_exp) in
    let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
    let c_sfl : bitstring = ServerFinishedLogInfo(scvl,m) in
    let ccvl = ClientBeforeFinishedLogInfo(c_sfl,log4) in
    let cfin = send_client_finished(ccvl,cfk) in
    let cfl = ClientFinishedLogInfo(ccvl, cfin) in
    let resumption_secret = get_resumption_secret(masterSecret, cfl) in
    event ClientTerm1((c_cr,c_log1,c_binder,c_log1',sr,log2,log3,m),(log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,sats,ems,resumption_secret));
    let c_sats: key = sats in
    (* We prove that c_cats, c_sats, c_ems and c_resumption_secret are secret 
       We compose 
       - with the record protocol with secret s_sats (ClientTerm is event e2)
       - with the record protocol with secret c_cats (ClientAccept is event e1)
       - with the PSK/PSKDHE handshake with secret c_resumption_secret (ClientAccept is event e1) *)
    event ClientTerm((c_cr,c_log1,c_binder,c_log1',sr,log2,log3,m),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,c_sats,ems));
    event ClientAccept((c_cr,c_log1,c_binder,c_log1',sr,log2,log3,m,log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,c_sats,ems,resumption_secret),i1);
    let c_cats: key = cats in
    let c_ems: key = ems in
    let c_resumption_secret : key = resumption_secret in
    out(io6,ClientFinishedOut(cfin)).

let Server = 
 !i6 <= N6
   in(io9,ClientHelloIn(s_cr: nonce,s_log1: bitstring,s_binder: bitstring,s_log1': bitstring));
   let (sr:nonce,chl:bitstring,cets_eems: two_keys,=true) = 
      recv_client_hello(earlySecret,binder_key,s_cr,s_log1,s_binder,s_log1') in
   event ServerEarlyTerm(s_cr, s_log1, s_binder);
   let s_eems: key = get_eems(cets_eems) in
   out(io10,ServerHelloOut(sr));
   ((*  for 0-RTT *)
   (in(io11', ());
   get c_table(=s_cr, =s_log1, =s_binder, =s_log1') in
      (* 1st case: messages from the client have not been altered.
         The key is good
	 We compose with tls13-core-RecordProtocol-0RTT.cv,
	 with secret c_cets
	 (ServerEarlyTerm1 is event e2 - non-injective variant) *)
	  let s_cets2: key = get_client_ets(cets_eems) in
          event ServerEarlyTerm1((s_cr, s_log1, s_binder, s_log1'), s_cets2);
	  out(io12', ())
   else
      (* 2nd case: messages from the client have been altered.
         The key will be secret and no message will actually be received on it.
         We compose with tls13-core-RecordProtocol-0RTT-badkey.cv,
	 using the variant "single process with key reuse". *)
	 let s_cets3: key = get_client_ets(cets_eems) in
	 event ServerEarlyTerm2((s_cr, s_log1, s_binder, s_log1'), s_cets3);
         find us <= N6 suchthat defined(s_cr[us], s_log1[us], s_binder[us], s_log1'[us], s_cets1[us]) &&
              s_cr[us] = s_cr && s_log1[us] = s_log1 && s_binder[us] = s_binder && s_log1'[us] = s_log1'
         then
	    (* We reuse a previous key s_cets1[us] *)
	    out(io13', ())
	 else
	    (* Not a previous key; these keys s_cets1 will be secret
	       and independent of each other *)
	    let s_cets1: key = s_cets3 in
	    out(io14', ()))
   | 
   in(io11,log2:bitstring);
   let sil = ServerHelloLogInfo(chl,sr,log2) in
   let (client_hk:key, server_hk: key, client_hiv: key, server_hiv: key, cfk: key, sfk: key, masterSecret: extracted) = onertt_hs_keys(sil,handshakeSecret) in
   out(io12,(client_hk, server_hk, client_hiv, server_hiv));
   in(io13,log3:bitstring);
   let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
   let m = send_server_finished(scvl,sfk) in
   let s_sfl = ServerFinishedLogInfo(scvl,m) in
   let cs_ats_exp = onertt_data_keys(masterSecret,s_sfl) in
   let cats = get_client_ats(cs_ats_exp) in
   let sats = get_server_ats(cs_ats_exp) in
   let ems = get_exporter_ms(cs_ats_exp) in
   (* We prove that s_sats is secret, already here for 0.5-RTT
      We then compose with the record protocol, with secret s_sats
      (ServerAccept is event e1) *)
   event ServerAccept((s_cr,s_log1,s_binder,s_log1',sr,log2,log3,m),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,sats,ems),i6);
   let s_sats: key = sats in
   out(io18,ServerFinishedOut(m));
   in(io19,ClientFinishedIn(log4, cfin));
   let ccvl = ClientBeforeFinishedLogInfo(s_sfl,log4) in
   let (resumption_secret: key, =true) = check_client_finished(masterSecret,ccvl,cfin,cfk) in
   event ServerTerm1((s_cr,s_log1,s_binder,s_log1',sr,log2,log3,m),(log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,sats,ems,resumption_secret));
   (* We prove that s_cats, s_ems, and s_resumption_secret are secret. *)
   let s_cats: key = cats in
   let s_ems: key = ems in
   let s_resumption_secret : key = resumption_secret in
   (* We compose 
      - with the record protocol with secret c_cats (ServerTerm is event e2) and 
      - with the PSK/PSKDHE handshake with secret c_resumption_secret (ServerTerm is event e2) *)
   event ServerTerm((s_cr,s_log1,s_binder,s_log1',sr,log2,log3,m,log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,s_cats,sats,s_ems,s_resumption_secret));
   out(io30, ())).

(* PSKDHE *)

let ClientDHE = 
!i2 <= N2
    in(dhe_io1,cdhe_log1: bitstring);
    let (cr: nonce,  x: key, gx: elt) = send_client_hello1DHE() in
    out(dhe_io1', (cr,gx));
    (* Give cr,gx to the adversary, so that it can compute binders for
       other PSKs (in cdhe_log1') and add them to the ClientHello message *) 
    in(dhe_io2', cdhe_log1': bitstring);
    let (cdhe_cr:nonce,x:key,cgx:elt, cdhe_binder: bitstring, chl: bitstring, cets_eems: two_keys) = 
       send_client_hello2DHE(earlySecret, binder_key, cr, x, gx, cdhe_log1, cdhe_log1') in
    insert cdhe_table(cdhe_cr, cgx, cdhe_log1, cdhe_binder, cdhe_log1');
    let cets = get_client_ets(cets_eems) in
    let cdhe_eems: key = get_eems(cets_eems) in
    event ClientEarlyAcceptDHE(cdhe_cr, cgx, cdhe_log1, cdhe_binder);
    (* 0-RTT: We compose with tls13-core-RecordProtocol-0RTT.cv, 
       with secret cdhe_cets 
       (ClientEarlyAcceptDHE1 is event e1 - non-injective variant). *)
    event ClientEarlyAcceptDHE1((cdhe_cr, cgx, cdhe_log1, cdhe_binder, cdhe_log1'), cets, i2);
    let cdhe_cets: key = cets in
    out(dhe_io2,ClientHelloOutDHE(cdhe_cr,cgx,cdhe_binder));
    in(dhe_io3,ServerHelloInDHE(sr,cgy,log2));
    let sil = ServerHelloLogInfoDHE(chl,sr,cgy,log2) in
    let (masterSecret:extracted,client_hk:key,server_hk:key,client_hiv:key,server_hiv:key,cfk:key,sfk:key,=true) = 
       recv_server_helloDHE(earlySecret,sil,x) in
    out(dhe_io4,(client_hk, server_hk, client_hiv, server_hiv));
    in(dhe_io5,(ServerFinishedIn(log3,m), ClientAuth: bool, log4: bitstring)); 
    let (cs_ats_exp:three_keys,=true) = recv_server_finished(sil,masterSecret,sfk,m,log3) in   
    let cats = get_client_ats(cs_ats_exp) in
    let sats = get_server_ats(cs_ats_exp) in
    let ems = get_exporter_ms(cs_ats_exp) in
    let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
    let c_sfl : bitstring = ServerFinishedLogInfo(scvl,m) in
    let ccvl = ClientBeforeFinishedLogInfo(c_sfl,log4) in
    let cfin = send_client_finished(ccvl,cfk) in
    let cfl = ClientFinishedLogInfo(ccvl, cfin) in
    let resumption_secret = get_resumption_secret(masterSecret, cfl) in
    event ClientTerm1((cdhe_cr,cgx,cdhe_log1,cdhe_binder,cdhe_log1',sr,cgy,log2,log3,m),(log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,sats,ems,resumption_secret));
    let cdhe_sats: key = sats in
    (* We prove that cdhe_cats, cdhe_sats, cdhe_ems and cdhe_resumption_secret are secret
       We compose 
       - with the record protocol with secret sdhe_sats (ClientTermDHE is event e2)
       - with the record protocol with secret cdhe_cats (ClientAcceptDHE is event e1)
       - with the PSK/PSKDHE handshake with secret cdhe_resumption_secret (ClientAcceptDHE is event e1) *)
    event ClientTermDHE((cdhe_cr,cgx,cdhe_log1,cdhe_binder,cdhe_log1',sr,cgy,log2,log3,m),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,cdhe_sats,ems));
    event ClientAcceptDHE((cdhe_cr,cgx,cdhe_log1,cdhe_binder,cdhe_log1',sr,cgy,log2,log3,m,log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,cdhe_sats,ems,resumption_secret),i2);
    let cdhe_cats: key = cats in
    let cdhe_ems: key = ems in
    let cdhe_resumption_secret: key = resumption_secret in
    out(dhe_io6,ClientFinishedOut(cfin)).

let ServerDHE = 
 !i7 <= N7
   in(dhe_io9,ClientHelloInDHE(sdhe_cr: nonce, sgx: elt, sdhe_log1: bitstring, sdhe_binder: bitstring, sdhe_log1': bitstring));
   let (sr:nonce,sgy:elt,handshakeSecret:extracted, chl: bitstring, cets_eems: two_keys,=true) = 
      recv_client_helloDHE(earlySecret,binder_key,sdhe_cr,sgx,sdhe_log1,sdhe_binder,sdhe_log1') in
   event ServerEarlyTermDHE(sdhe_cr,sgx,sdhe_log1,sdhe_binder);
   let sdhe_eems: key = get_eems(cets_eems) in
   out(dhe_io10,ServerHelloOutDHE(sr,sgy));
   ((*  for 0-RTT *)
   (in(dhe_io11', ());
   get cdhe_table(=sdhe_cr, =sgx, =sdhe_log1, =sdhe_binder, =sdhe_log1') in
      (* 1st case: messages from the client have not been altered.
         The key is good
	 We compose with tls13-core-RecordProtocol-0RTT.cv,
	 with secret cdhe_cets
	 (ServerEarlyTerm1 is event e2 - non-injective variant)  *)
	  let sdhe_cets2: key = get_client_ets(cets_eems) in
          event ServerEarlyTermDHE1((sdhe_cr, sgx, sdhe_log1, sdhe_binder, sdhe_log1'), sdhe_cets2);
	  out(io12', ())
   else
      (* 2nd case: messages from the client have been altered.
         The key will be secret and no message will actually be received on it.
         We compose with tls13-core-RecordProtocol-0RTT-badkey.cv,
	 using the variant "single process with key reuse". *)
	 let sdhe_cets3: key = get_client_ets(cets_eems) in
	 event ServerEarlyTermDHE2((sdhe_cr, sgx, sdhe_log1, sdhe_binder, sdhe_log1'), sdhe_cets3);
         find us <= N7 suchthat defined(sdhe_cr[us], sgx[us], sdhe_log1[us], sdhe_binder[us], sdhe_log1'[us], sdhe_cets1[us]) &&
              sdhe_cr[us] = sdhe_cr && sgx[us] = sgx && sdhe_log1[us] = sdhe_log1 && 
              sdhe_binder[us] = sdhe_binder && sdhe_log1'[us] = sdhe_log1'
         then
	    (* We reuse a previous key sdhe_cets1[us] *)
	    out(io13', ())
	 else
	    (* Not a previous key; these keys sdhe_cets1 will be secret
	       and independent of each other *)
	    let sdhe_cets1: key = sdhe_cets3 in
	    out(io14', ()))
   |
   in(dhe_io11,log2:bitstring);
   let sil = ServerHelloLogInfoDHE(chl,sr,sgy,log2) in
   let (client_hk:key, server_hk: key, client_hiv: key, server_hiv: key, cfk: key, sfk: key, masterSecret: extracted) = onertt_hs_keys(sil,handshakeSecret) in
   out(dhe_io12,(client_hk, server_hk, client_hiv, server_hiv));
   in(dhe_io13,log3:bitstring);
   let scvl = ServerBeforeFinishedLogInfo(sil,log3) in
   let m = send_server_finished(scvl,sfk) in
   let s_sfl = ServerFinishedLogInfo(scvl,m) in
   let cs_ats_exp = onertt_data_keys(masterSecret,s_sfl) in
   let cats = get_client_ats(cs_ats_exp) in
   let sats = get_server_ats(cs_ats_exp) in
   let ems = get_exporter_ms(cs_ats_exp) in
   (* We prove that sdhe_sats is secret, already here for 0.5-RTT
      We then compose with the record protocol, with secret sdhe_sats
      (ServerAcceptDHE is event e1) *)
   event ServerAcceptDHE((sdhe_cr,sgx,sdhe_log1,sdhe_binder,sdhe_log1',sr,sgy,log2,log3,m),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,sats,ems),i7);
   let sdhe_sats: key = sats in
   out(dhe_io18,ServerFinishedOut(m));
   in(dhe_io19,ClientFinishedIn(log4, cfin));
   let ccvl = ClientBeforeFinishedLogInfo(s_sfl,log4) in
   let (resumption_secret: key, =true) = check_client_finished(masterSecret,ccvl,cfin,cfk) in
   event ServerTerm1((sdhe_cr,sgx,sdhe_log1,sdhe_binder,sdhe_log1',sr,sgy,log2,log3,m),(log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,cats,sats,ems,resumption_secret));
   (* We prove that sdhe_cats, sdhe_ems, and sdhe_resumption_secret are secret 
      We compose with the record protocol for sdhe_cats and 
      with the PSK/PSKDHE handshake for s_resumption_secret *)
   let sdhe_cats: key = cats in
   let sdhe_ems: key = ems in
   let sdhe_resumption_secret: key = resumption_secret in
   (* We compose 
      - with the record protocol with secret cdhe_cats (ServerTermDHE is event e2) and 
      - with the PSK/PSKDHE handshake with secret cdhe_resumption_secret (ServerTermDHE is event e2) *)
   event ServerTermDHE((sdhe_cr,sgx,sdhe_log1,sdhe_binder,sdhe_log1',sr,sgy,log2,log3,m,log4,cfin),(client_hk,server_hk,client_hiv,server_hiv,cfk,sfk,sdhe_cats,sdhe_sats,sdhe_ems,sdhe_resumption_secret));
   out(dhe_io30, ())).



process 
  in(io20,());
  new hk: hashkey; (* Key that models the choice of the random oracle *)
  new psk: key;
  let earlySecret = HKDF_extract_zero_salt(hk, psk) in
  let binder_key = Derive_Secret_psk_binder_key(earlySecret) in
  let handshakeSecret = HKDF_extract_zero1(earlySecret) in
      (* handshake secret for the PSK variant without DHE *)
  out(io21,());
  ((in(io22, ()); out(io23, ()); 
      ((in(io24, ()); out(io25, ()); (Client | ClientDHE)) | 
       (in(io26, ()); out(io27, ()); (Server | ServerDHE)))) | 
   hashoracle)


(* 

This code is equivalent to:

  in(io20,());
  new hk: hashkey; 
  out(io21,());
  ((in(io22, ()); new psk: key; out(io23, ()); 
      ((in(io24, ()); 
        let earlySecret = HKDF_extract_zero_salt(hk, psk) in
        let binder_key = Derive_Secret_psk_binder_key(earlySecret) in
        let handshakeSecret = HKDF_extract_zero1(earlySecret) in
        out(io25, ()); (Client | ClientDHE)) | 
       (in(io26, ()); 
        let earlySecret = HKDF_extract_zero_salt(hk, psk) in
        let binder_key = Derive_Secret_psk_binder_key(earlySecret) in
        let handshakeSecret = HKDF_extract_zero1(earlySecret) in
        out(io27, ()); (Server | ServerDHE)))) | 
   hashoracle)

The version above is easier to verify for CryptoVerif,
because  
  let earlySecret = HKDF_extract_zero_salt(hk, psk) in
  let binder_key = Derive_Secret_psk_binder_key(earlySecret) in
  let handshakeSecret = HKDF_extract_zero1(earlySecret) in
are called once, and before calls to the hash oracle by the
adversary, so it is easy to show that they generate fresh
random values, shared by Client, Server, ClientDHE, ServerDHE.
The commented version is the one we use for the composition results. 

*)

(* EXPECTED
All queries proved.
482.898s (user 482.646s + system 0.252s), max rss 1711360K
END *)
