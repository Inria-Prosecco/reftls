
channel io1, io2, io3, io4, io5, io6, io7, io8, io9, io10,
	io11, io12, io13, io14, io15, io16, io17, io18, io19, io20,
	io21, io22, io23, io24, io25, io26, io27, io28, io29, io30,
	cCorrupt.

proof {
      crypto uf_cma_corrupt(sign) kseed;
      insert 584 "find j' <= N1 suchthat defined(gx_331[j']) && gx_387 = gx_331[j'] then";
      SArename gy_394;
      insert 45 "find j <= N6 suchthat defined(gy_533[j], gx_387[j]) && gx_331 = gx_387[j] && gy_335 = gy_533[j] then";
      crypto rom(HKDF_extract_ES);
      remove_assign binder s_347;
      remove_assign binder s_395;
      simplify;
      crypto gdh(exp) "variables: x_330 -> @3_a, y_537 -> @3_b .";
      auto;
(*    crypto prf(HMAC) *;
      crypto id(key2extracted) *;
      crypto prf(HMAC) *;
      crypto suf_cma(mac) *; *)
      SArename r3_750;
      SArename r3_753;
      SArename r3_756;
      SArename r3_759;
      SArename r3_786;
      SArename r3_789;
      move binder "@9_ma2_8624";
      SArename "@9_ma2_8624";
      move binder "@9_ma2_8834";
      SArename "@9_ma2_8834";
      success
}



type key [large, fixed].
const zero_key: key.

type elt [large, bounded].
fun element2key(elt): key [compos].
fun elt2bitstring(elt): bitstring [compos].

(* Gap Diffie-Hellman assumption.
   TO DO are the groups prime order? *)

define GDH_prime_order(G, Z, g, exp, mult, pGDH) {

fun exp(G,Z): G.
fun exp'(G,Z): G.
const g:G.

fun mult(Z,Z): Z. 
equation commut(mult).

(* exponents multiply *)

forall a:G, x:Z, y:Z;
  exp(exp(a,x), y) = exp(a, mult(x,y)).
forall a:G, x:Z, y:Z;
  exp'(exp'(a,x), y) = exp'(a, mult(x,y)).

(* injectivity *)

forall x:Z, y:Z; (exp(g,x) = exp(g,y)) = (x = y).
forall x:Z, y:Z; (exp'(g,x) = exp'(g,y)) = (x = y).

(* According to http://link.springer.com/chapter/10.1007%2F11745853_14,
page 214, the order of the base point is a prime
namely 2^252 + 27742317777372353535851937790883648493.
So exp(x,y) = exp(x',y) implies y = y' (provided y is not a multiple
of this prime; if y is a correctly generated secret key, that cannot
happen)
-- TO DO check for TLS what groups are used *)

forall x:G, x':G, y:Z; (exp(x,y) = exp(x',y)) = (x = x').
forall x:G, x':Z, y:Z; (exp(x,y) = exp(g, mult(x',y))) = (x = exp(g,x')).

forall x:G, y:Z, y':Z; (exp(x,y) = exp(x,y')) = (y = y').

(* collision between products *)

collision new x1:Z; new x2:Z; new x3:Z; new x4:Z; 
  mult(x1,x2) = mult(x3,x4) <=(1/|Z|)=> false. 

collision new x1:Z; new x2:Z; 
  mult(x1,x1) = mult(x2,x2) <=(1/|Z|)=> false. 

forall x:Z, y:Z, y':Z; 
  (mult(x,y) = mult(x,y')) = (y = y').

(* replace a random group element with an exponentiation, and conversely *)

param N, N'.

equiv group_to_exp_strict(exp)
      !N new X:G; (OX() := X, !N' OXm(m:Z) [useful_change] := exp(X,m))
<=(0)=> [computational]
      !N new x:Z; (OX() := exp(g,x), !N' OXm(m:Z) := exp(g,mult(x,m))).

(* This equivalence is very general, apply it only manually, because
   otherwise it might be applied too often.  The equivalence above is
   particular case applied only when X is inside exp, and good for
   automatic proofs. *)

equiv group_to_exp(exp)
      !N new X:G; OX() := X 
<=(0)=> [manual, computational]    
      !N new x:Z; OX() := exp(g,x).


equiv exp_to_group(exp)
      !N new x:Z; OX() := exp(g,x)
<=(0)=> [computational]
      !N new X:G; OX() := X.

equiv exp'_to_group(exp)
      !N new x:Z; OX() := exp'(g,x)
<=(0)=> [computational]
      !N new X:G; OX() := X.

(* the GDH assumption
    This equivalence says that, when exp(g,a[i]) and exp(g,b[j]) are known to the
    adversary, the adversary can compute exp(g, mult(a[i], b[j])) only with
    negligible probability, even in the presence of a DDH oracle
    DDH(G,A,B,C) tells whether A = G^a, B = G^b, and C = G^{ab} for some a,b,
    that is DDH(G,A,B,C) is (log_G(A) * log_G(B) = log_G(C)). *) 

const mark: bitstring.

param na, naDDH, naDDH1, naDDH2, naDDH3, naDDH4, naDDH5, naDDH6, naDDH7, naDDH8,
      nb, nbDDH, nbDDH1, nbDDH2, nbDDH3, nbDDH4, nbDDH5, nbDDH6, nbDDH7, nbDDH8.

equiv gdh(exp)
    !na new a:Z; (
      OA() := exp(g,a), 
      Oa() [3] := a,
      !naDDH1 ODDHa1(m:G, m':G) := m = exp(m', a),
      !naDDH2 ODDHa2(m:G,m':G,j<=nb) := exp(m, b[j]) = exp(m',a),
      !naDDH3 ODDHa3(m:G,m':G,j<=na) := exp(m, a[j]) = exp(m',a),
      !naDDH4 ODDHa4(m:G,j'<=nb,j<=nb) := exp(m, b[j]) = exp(g,mult(b[j'],a)),
      !naDDH5 ODDHa5(m:G,j'<=nb,j<=na) := exp(m, a[j]) = exp(g,mult(b[j'],a)),
      !naDDH6 ODDHa6(m:G,j'<=na,j<=nb) := exp(m, b[j]) = exp(g,mult(a[j'],a)),
      !naDDH7 ODDHa7(m:G,j'<=na,j<=na) := exp(m, a[j]) = exp(g,mult(a[j'],a)),
      !naDDH ODDHa(m:G, j<=nb) [useful_change] := m = exp(g, mult(b[j], a)),
      !naDDH8 ODDHa8(m:G,j<=na) [3] := m = exp(g,mult(a[j], a))
    ),
    !nb new b:Z; (
      OB() := exp(g,b),
      Ob() [3] := b,
      !nbDDH1 ODDHb1(m:G, m':G) := m = exp(m', b),
      !nbDDH2 ODDHb2(m:G,m':G,j<=nb) := exp(m, b[j]) = exp(m',b),
      !nbDDH3 ODDHb3(m:G,m':G,j<=na) := exp(m, a[j]) = exp(m',b),
      !nbDDH4 ODDHb4(m:G,j'<=nb,j<=nb) := exp(m, b[j]) = exp(g,mult(b[j'],b)),
      !nbDDH5 ODDHb5(m:G,j'<=nb,j<=na) := exp(m, a[j]) = exp(g,mult(b[j'],b)),
      !nbDDH6 ODDHb6(m:G,j'<=na,j<=nb) := exp(m, b[j]) = exp(g,mult(a[j'],b)),
      !nbDDH7 ODDHb7(m:G,j'<=na,j<=na) := exp(m, a[j]) = exp(g,mult(a[j'],b)),
      !nbDDH ODDHb(m:G, j<=na) := m = exp(g, mult(a[j], b)),
      !nbDDH8 ODDHb8(m:G,j<=nb) [3] := m = exp(g,mult(b[j], b))
    )
<=((#ODDHa + #ODDHa1 + #ODDHa4 + #ODDHa5 + #ODDHb + #ODDHb1 + #ODDHb6 + #ODDHb7) *
	   max(1, 7.4*#Oa) * max(1, 7.4*#Ob) *
	   pGDH(time + (na + nb + #ODDHa + #ODDHa1 + #ODDHb + #ODDHb1) * time(exp),
	   #ODDHa1 + #ODDHa2 + #ODDHa3 + #ODDHa4 + #ODDHa5 + #ODDHa6 + #ODDHa7 + #ODDHa8 +
	   #ODDHb1 + #ODDHb2 + #ODDHb3 + #ODDHb4 + #ODDHb5 + #ODDHb6 + #ODDHb7 + #ODDHb8))=> [computational]
    !na new a:Z [unchanged]; (
      OA() := exp'(g,a), 
      Oa() := let ka:bitstring = mark in a,
      !naDDH1 ODDHa1(m:G, m':G) := if defined(ka) then m = exp'(m', a) else 
      		  	   find u<=nb suchthat defined(b[u],kb[u]) && m' = exp'(g,b[u]) then m = exp'(m', a) else
			   find u<=nb suchthat defined(b[u]) && m' = exp'(g,b[u]) then false else
                               (* by CDH, if neither a nor b[u] are leaked, then m = exp(g, b[u]*a) is impossible *)
			   m = exp'(m', a)
			       (* GDH allows to compute m = exp(m',a) for any m and m', without leaking a, 
			          as it is DDH(g, exp(g,a), m', m) *),
      !naDDH2 ODDHa2(m:G,m':G,j<=nb) := exp'(m, b[j]) = exp'(m',a),
      	   (* GDH allows to compute exp(m, b[j]) = exp(m',a) for any m and m', 
	      without leaking a, as it is DDH(exp(g,a), exp(g,b[j]), m, m')
	      Indeed, 
 	      D(exp(g,a),exp(g,b[j]),m,m') 
      	        = (log_{g^a}(g^b[j]) * log_{g^a}(m) = log_{g^a}(m'))
      		= (b[j]/a * log_g(m)/a = log_g(m')/a)
      		= (b[j] * log_g(m) = a log_g(m'))
      		= (m^b[j] = m'^a). *)
      !naDDH3 ODDHa3(m:G,m':G,j<=na) := exp'(m, a[j]) = exp'(m',a),
      	    (* Similar to ODDHa2 *)
      !naDDH4 ODDHa4(m:G,j'<=nb,j<=nb) :=
      	      find u<=nb suchthat defined(kb[u],b[u]) && b[j'] = b[u] then exp'(m, b[j]) = exp'(g,mult(b[j'],a)) else
	      if defined(ka) then exp'(m, b[j]) = exp'(g,mult(b[j'],a)) else
      	      b[j] = b[j'] && m = exp'(g,a),
      !naDDH5 ODDHa5(m:G,j'<=nb,j<=na) :=
      	      find u<=nb suchthat defined(kb[u],b[u]) && b[j'] = b[u] then exp'(m, a[j]) = exp'(g,mult(b[j'],a)) else
	      if defined(ka) then exp'(m, a[j]) = exp'(g,mult(b[j'],a)) else
      	      a[j] = a && m = exp'(g,b[j']),
      !naDDH6 ODDHa6(m:G,j'<=na,j<=nb) := exp'(m, b[j]) = exp'(g,mult(a[j'],a)),
      !naDDH7 ODDHa7(m:G,j'<=na,j<=na) := exp'(m, a[j]) = exp'(g,mult(a[j'],a)),
            (* ODDHa4..7 are particular cases of ODDHa2 or ODDHa3, with m' = exp(g, b[j'])
	       or m' = exp(g, a[j']).
	       We need to consider all these forms because CryptoVerif rewrites
	       exp(exp(g,b[j']),a) into exp(g,mult(b[j'],a)), and it would not
	       detect exp(g,mult(b[j'],a)) as an instance of exp(m',a). *)
      !naDDH ODDHa(m:G, j<=nb) :=
      	     find u<=nb suchthat defined(kb[u],b[u]) && b[j] = b[u] then m = exp'(g, mult(b[j], a)) else 
             if defined(ka) then m = exp'(g, mult(b[j], a)) else false,
	    (* ODDHa is a particular case of ODDHa1 in which can apply the CDH assumption,
	       provided a and b[j] are not leaked. *)
      !naDDH8 ODDHa8(m:G,j<=na) := m = exp'(g,mult(a[j], a))
            (* ODDHa8 is a particular case of ODDHa1 in which we do not apply
	       the CDH assumption, since we apply it between a's and b's *)
    ),
    !nb new b:Z [unchanged]; (
      OB() := exp'(g,b), 
      Ob() := let kb:bitstring = mark in b,
      !nbDDH1 ODDHb1(m:G, m':G) := if defined(kb) then m = exp'(m', b) else 
      		  	   find u<=na suchthat defined(a[u],ka[u]) && m' = exp'(g,a[u]) then m = exp'(m', b) else
      		  	   find u<=na suchthat defined(a[u]) && m' = exp'(g,a[u]) then false else
                               (* by CDH, if neither a nor b[u] are leaked, then m = exp(g, a[u]*b) is impossible *)
			   m = exp'(m', b)
			       (* GDH allows to compute m = exp(m',a) for any m and m', without leaking a *),
      !nbDDH2 ODDHb2(m:G,m':G,j<=nb) := exp'(m, b[j]) = exp'(m',b),
      !nbDDH3 ODDHb3(m:G,m':G,j<=na) := exp'(m, a[j]) = exp'(m',b),
      !nbDDH4 ODDHb4(m:G,j'<=nb,j<=nb) := exp'(m, b[j]) = exp'(g,mult(b[j'],b)),
      !nbDDH5 ODDHb5(m:G,j'<=nb,j<=na) := exp'(m, a[j]) = exp'(g,mult(b[j'],b)),
      !nbDDH6 ODDHb6(m:G,j'<=na,j<=nb) :=
      	      find u<=na suchthat defined(ka[u],a[u]) && a[j'] = a[u] then exp'(m, b[j]) = exp'(g,mult(a[j'],b)) else
	      if defined(kb) then exp'(m, b[j]) = exp'(g,mult(a[j'],b)) else
      	      b[j] = b && m = exp'(g,a[j']),
      !nbDDH7 ODDHb7(m:G,j'<=na,j<=na) :=
      	      find u<=na suchthat defined(ka[u],a[u]) && a[j'] = a[u] then exp'(m, a[j]) = exp'(g,mult(a[j'],b)) else
	      if defined(kb) then exp'(m, a[j]) = exp'(g,mult(a[j'],b)) else
      	      a[j] = a[j'] && m = exp'(g,b),
      !nbDDH ODDHb(m:G, j<=na) := find u<=na suchthat defined(ka[u],a[u]) && a[j] = a[u] then m = exp'(g, mult(a[j], b)) else 
                            if defined(kb) then m = exp'(g, mult(a[j], b)) else false,
      !nbDDH8 ODDHb8(m:G,j<=nb) := m = exp'(g,mult(b[j], b))
    ).

    (* We need to consider both forms m = exp(m', a) and m = exp(g,
    mult(b[j], a)) in the equivalence, because, when m' is known to be
    exp(g, b[j]), CryptoVerif is going to simplify m = exp(m', a) into
    m = exp(g, mult(b[j], a)), and the procedure that tests whether a
    term in the game matches a term in the equivalence would not
    recognize that m = exp(g, mult(b[j], a)) in the game matches m =
    exp(m', a) in the equivalence. *)

}


proba pGDH.
expand GDH_prime_order(elt, key, G, exp, mult, pGDH).

letfun dh_keygen() =
   new x:key;
   (x,exp(G,x)).

(* Labels for HKDF_expand *)

type label.
const hk_label:label.
const client_hts_label:label.
const server_hts_label:label.
const fin_label:label.
const hke_label:label.
const client_ts_label:label.
const server_ts_label:label.
const dk_label:label.
const dk0_label:label.

type extracted [large, fixed].
(* In fact, the function key2extracted is the identity *)
fun key2extracted(key):extracted [compos]. 

param N, N2, N3, N4.

equiv id(key2extracted)
      !N new k:key; Ok() := key2extracted(k)
  <=(0)=>
      !N new e:extracted; Ok():= e.

(* HKDF_extract_ES, that is, HKDF_extract with salt argument 
   Early_secret = HKDF_extract(0,0), is a random oracle. *)

type hashkey [large,fixed].

expand ROM_hash(hashkey, elt, extracted, HKDF_extract_ES).

param qH [noninteractive].
channel c1, c2.
let hashoracle = ! qH in(c1, x:elt); out(c2, HKDF_extract_ES(hk,x)). 

(* HMAC is a pseudo random function *)

type hash.

fun HMAC1(extracted):extracted.
fun HMAC2(extracted,label,hash):key.

proba Pprf.

equiv prf(HMAC)
       !N3 new r: extracted; (O1() := HMAC1(r),
       	       	  	      !N O2(y:label, z:hash) := HMAC2(r,y,z))
     <=(N3 * Pprf(time + (N3-1)*(N * time(HMAC2, maxlength(y), maxlength(z))), N, maxlength(y), maxlength(z)))=>
       !N3 (O1() := new r2: extracted; r2,
            !N O2(y:label, z:hash) :=
	        find[unique] j<=N suchthat defined(y[j],z[j],r3[j]) && y = y[j] && z = z[j] then r3[j] 
		else new r3: key; r3).

type hashkey' [large,fixed].
proba Phash.
expand CollisionResistant_hash(hashkey', bitstring, hash, Hash, Phash).

const zero: bitstring.
const empty_bytes:hash.

letfun HKDF_expand_label(Secret: extracted, Label: label, HashValue: hash) =
       HMAC2(Secret, Label, HashValue).

letfun Derive_secret(hk': hashkey', Secret: extracted, Label: label, Messages: bitstring) = 
       HKDF_expand_label(Secret, Label, Hash(hk', Messages)).

letfun HKDF_extract_zero(m: extracted) =
       HMAC1(m).

(* SUF-CMA MAC *)

define SUF_CMA_mac_nokgen(mkey, macinput, macres, mac, check, Pmac) {

fun mac(mkey, macinput):macres.
fun check(mkey, macinput, macres): bool.

fun mac2(mkey, macinput):macres.

forall m:macinput, k:mkey;
	check(k, m, mac(k, m)).

forall m:macinput, k:mkey, m':macres;
	(mac(k,m) = m') = check(k, m, m').

equiv suf_cma(mac)
      ! N3 new k: mkey;(
	 !N Omac(x: macinput) := mac(k, x),
	 !N2 Ocheck(m: macinput, ma: macres) := check(k, m, ma))
     <=(N3 * Pmac(time + (N3-1)*(N*time(mac,maxlength(x)) + N2*time(check,maxlength(m),maxlength(ma))), N, N2, max(maxlength(x), maxlength(m))))=> [computational]
      ! N3 new k: mkey [unchanged];(
	 !N Omac(x: macinput) := let ma2:macres = mac2(k, x) in ma2,
	 !N2 Ocheck(m: macinput, ma: macres) := 
	    find j <= N suchthat defined(x[j], ma2[j]) && (m = x[j]) && ma = ma2[j] then true else false).

}

proba Pmac.
expand SUF_CMA_mac_nokgen(key, bitstring, bitstring, mac, check, Pmac).

fun enc(key,bitstring): bitstring.
fun dec(key,bitstring): bitstring.
forall k:key, m:bitstring;
    dec(k,enc(k,m)) = m.

type certificate [bounded].
const anon_cert:certificate.

(* UF-CMA signatures
   I suppose that signatures are probabilistic, and
   I generate the public key and private key from a common seed
   (instead of generating the public key from the private key).
   Verify returns true when the verification succeeds 
   (instead of returning the message) *)

define UF_CMA_signature_key_first(keyseed, pkey, skey, signinput, signature, seed, skgen, pkgen, sign, check, Psign, Psigncoll) {

const mark: bitstring.

fun sign(skey, signinput, seed): signature.
fun skgen(keyseed):skey.
fun pkgen(keyseed):pkey.
fun check(pkey, signinput, signature): bool.

fun sign2(skey, signinput, seed): signature.
fun skgen2(keyseed):skey.
fun pkgen2(keyseed):pkey.
fun check2(pkey, signinput, signature): bool.

forall m:signinput, r:keyseed, r2:seed; 
	check(pkgen(r), m, sign(skgen(r), m, r2)) = true.
forall m:signinput, r:keyseed, r2:seed; 
	check2(pkgen2(r), m, sign2(skgen2(r), m, r2)) = true.

equiv uf_cma(sign)
       !N3 new r: keyseed; (Opk() [2] := pkgen(r),
			    !N2 new r2: seed; Osign(x: signinput) := sign(skgen(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) := check(pkgen(r), m1, si1)),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) [3] := check(y, m, si) [all]
     <=(N3 * Psign(time + (N4+N-1) * time(check, max(maxlength(m1), maxlength(m)), max(maxlength(si1), maxlength(si))) + (N3-1)*(time(pkgen) + time(skgen) + N2 * time(sign, maxlength(x)) + N * time(check, maxlength(m1), maxlength(si1))), N2, maxlength(x)))=> [computational]
       !N3 new r: keyseed [unchanged]; 
       	       	  	   (Opk() := pkgen2(r),
			    !N2 new r2: seed [unchanged]; Osign(x: signinput) := sign2(skgen2(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) :=
                              find j <= N2 suchthat defined(x[j]) && m1 = x[j] && check2(pkgen2(r), m1, si1) then true else false),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) :=
		find j <= N2, k <= N3 suchthat defined(x[j,k],r[k]) && y = pkgen2(r[k]) && m = x[j,k] && check2(y, m, si) then true else
		find k <= N3 suchthat defined(r[k]) && y = pkgen2(r[k]) then false else
		check(y,m,si).

equiv uf_cma_corrupt(sign)
       !N3 new r: keyseed; (Opk() [useful_change] [2] := pkgen(r),
			    !N2 new r2: seed; Osign(x: signinput) [useful_change] := sign(skgen(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) [useful_change] := check(pkgen(r), m1, si1),
			    Ocorrupt() [10] := r),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) [3] := check(y, m, si) [all]
     <=(N3 * Psign(time + (N4+N-1) * time(check, max(maxlength(m1), maxlength(m)), max(maxlength(si1), maxlength(si))) + (N3-1)*(time(pkgen) + time(skgen) + N2 * time(sign, maxlength(x)) + N * time(check, maxlength(m1), maxlength(si1))), N2, maxlength(x)))=> [manual,computational]
       !N3 new r: keyseed [unchanged]; 
       	       	  	   (Opk() := pkgen2(r),
			    !N2 new r2: seed [unchanged]; Osign(x: signinput) := sign2(skgen2(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) :=
			      if defined(corrupt) then check2(pkgen2(r), m1, si1) else
                              find j <= N2 suchthat defined(x[j]) && m1 = x[j] && check2(pkgen2(r), m1, si1) then true else false,
			    Ocorrupt() := let corrupt: bitstring = mark in r),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) :=
		find k <= N3 suchthat defined(r[k],corrupt[k]) && y = pkgen2(r[k]) then check2(y, m, si) else
		find j <= N2, k <= N3 suchthat defined(x[j,k],r[k]) && y = pkgen2(r[k]) && m = x[j,k] && check2(y, m, si) then true else
		find k <= N3 suchthat defined(r[k]) && y = pkgen2(r[k]) then false else
		check(y,m,si).

collision new r1:keyseed; new r2:keyseed; 
	pkgen(r1) = pkgen(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	pkgen(r1) = pkgen2(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	pkgen2(r1) = pkgen2(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	skgen(r1) = skgen(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	skgen(r1) = skgen2(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	skgen2(r1) = skgen2(r2) <=(Psigncoll)=> false.

}

type keyseed [large, bounded].
type seed [large, bounded].
type skey [bounded].
proba Psign.
proba Psigncoll.
expand UF_CMA_signature_key_first(keyseed, certificate, skey, bitstring, bitstring, seed, 
       		        skgen, pkcert, sign, verify, Psign, Psigncoll).

type nonce [large, fixed].

(* Message formats *)

fun ClientHello(nonce, elt): bitstring [compos].
fun ServerHelloIn(nonce, elt, bitstring): bitstring [compos].
fun ServerHelloOut(nonce, elt): bitstring [compos].
fun ServerCertificateIn(certificate,bitstring): bitstring [compos].
fun ServerFinishedIn(certificate,bitstring,bitstring,bitstring): bitstring [compos].
fun ServerCertificateVerifyOut(bitstring): bitstring [compos].
fun ServerFinishedOut(bitstring): bitstring [compos].

fun ClientCertificateVerifyOut(bitstring): bitstring [compos].
fun ClientFinishedOut(bitstring): bitstring  [compos].
fun ClientFinishedIn(bitstring): bitstring  [compos].
fun ClientFinishedAuthIn(certificate,bitstring,bitstring,bitstring,bitstring): bitstring  [compos].

(* Logs *)

fun ServerHelloLogInfo(nonce,elt,nonce,elt,bitstring): bitstring [compos].
fun ServerCertificateLogInfo(bitstring,certificate,bitstring): bitstring [compos].
fun ServerCertificateVerifyLogInfo(bitstring,bitstring): bitstring [compos].
fun ServerFinishedLogInfo(bitstring,bitstring): bitstring [compos].

(*
type clientCertificateLogInfo.
fun ClientCertificateLogInfo(serverFinishedLogInfo,certificate): clientCertificateLogInfo [compos].
fun getClientCertificateLogInfo(bitstring): clientCertificateLogInfo.

type clientCertificateVerifyLogInfo.
fun ClientCertificateVerifyLogInfo(clientCertificateLogInfo,bitstring): clientCertificateVerifyLogInfo [compos].
fun getClientCertificateVerifyLogInfo(bitstring): clientCertificateVerifyLogInfo.
*)
table serverLongTermKeys(certificate,skey).
table clientLongTermKeys(certificate,skey).
table clientCache(elt,certificate).

table oneRTTClientDataKey(nonce,nonce,certificate,certificate,key,key).
table oneRTTServerDataKey(nonce,nonce,certificate,certificate,key,key).
table oneRTTServerFalseStartKey(nonce,nonce,certificate,key,key,key,key,hash).
table zeroRTTClientKey(nonce,certificate,certificate,key,key).
table zeroRTTServerKey(nonce,certificate,certificate,key,key).


event SendClient(nonce,nonce,certificate,certificate,bitstring).
event RecvServer(nonce,nonce,certificate,certificate,bitstring).
event SendServer(nonce,nonce,certificate,certificate,bitstring).
event RecvClient(nonce,nonce,certificate,certificate,bitstring).

event SendClient0(nonce,certificate,certificate,key,bitstring).
event RecvServer0(nonce,certificate,certificate,key,bitstring).
event SendServer0(nonce,nonce,certificate,bitstring).
event RecvClient0(nonce,nonce,certificate,bitstring).


(* Secrecy of the key *)

query secret client_dk_secret.
query secret server_dk_secret.

(* Authentication of the server to the client *)

event ClientTerm(nonce,elt,nonce,elt,key,key,key,key,key,key).
event ServerAccept(nonce,elt,nonce,elt,key,key,key,key,key,key).

query cr: nonce, gx: elt, sr: nonce, gy: elt, client_hk: key, server_hk: key,
      cfk: key, sfk: key, client_dk: key, server_dk: key;
      event ClientTerm(cr,gx,sr,gy,client_hk,server_hk,cfk,sfk,client_dk,server_dk) ==>
      	    ServerAccept(cr,gx,sr,gy,client_hk,server_hk,cfk,sfk,client_dk,server_dk).

(*
const secret_msg0:bitstring.
const secret_msg1:bitstring.
const secret_msg2:bitstring.
const secret_msg3:bitstring.
*)

letfun send_client_hello() = 
       new cr:nonce;
       new x:key;
       let gx = exp(G,x) in
       (cr,x,gx).


letfun recv_server_hello(hk: hashkey, hk': hashkey', sil:bitstring, x:key) = 
  let ServerHelloLogInfo(cr,gx,sr,gy,l) = sil in
  (let s = exp(gy,x) in
   let handshakeSecret = HKDF_extract_ES(hk,s) in
   let client_hts = Derive_secret(hk',handshakeSecret,client_hts_label,sil) in    
   let server_hts = Derive_secret(hk',handshakeSecret,server_hts_label,sil) in
   let client_hk = HKDF_expand_label(key2extracted(client_hts),hke_label,empty_bytes) in
   let server_hk = HKDF_expand_label(key2extracted(server_hts),hke_label,empty_bytes) in
   let cfk = HKDF_expand_label(key2extracted(client_hts),fin_label,empty_bytes) in
   let sfk = HKDF_expand_label(key2extracted(server_hts),fin_label,empty_bytes) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (masterSecret,client_hk,server_hk,cfk,sfk,true))
  else (key2extracted(zero_key),zero_key,zero_key,zero_key,zero_key,false).
   

letfun recv_server_finished(hk': hashkey', si:bitstring, masterSecret:extracted, sfk: key,
       		            cert:certificate, s:bitstring, m:bitstring, 
			    log1:bitstring) =
   let scl = ServerCertificateLogInfo(si,cert,log1) in
   let scvl = ServerCertificateVerifyLogInfo(scl,s) in
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let client_ts0 = Derive_secret(hk', masterSecret,client_ts_label,sfl) in
   let server_ts0 = Derive_secret(hk', masterSecret,server_ts_label,sfl) in
   let client_dk = HKDF_expand_label(key2extracted(client_ts0),dk_label,empty_bytes) in
   let server_dk = HKDF_expand_label(key2extracted(server_ts0),dk_label,empty_bytes) in
   if verify(cert,scl,s) &&
      mac(sfk,scvl) = m then
       (client_dk,server_dk,true)
   else (client_dk,server_dk,false).
			   
letfun send_client_finished_no_auth(sfl:bitstring, cfk:key) = 
       mac(cfk,sfl).
(*
letfun send_client_certificate_verify(ccl:clientCertificateLogInfo, sk:skey, log:bitstring) = 
   new s: seed;
   let sg = sign(sk,log,s) in
   if getClientCertificateLogInfo(log) = ccl then
        (sg,true)
   else (sg,false).

letfun send_client_finished_client_auth(ccvl:clientCertificateVerifyLogInfo, cfk:key, log3: bitstring) = 
   let cfin = mac(cfk,log3) in			    
   if getClientCertificateVerifyLogInfo(log3) = ccvl then
        (cfin,true)
   else (cfin,false).
*)

letfun recv_client_hello(hk: hashkey, cr:nonce, gx:elt) = 
   new sr:nonce;
   new y: key;
   let gy = exp(G,y) in
   let s = exp(gx,y) in
   let handshakeSecret = HKDF_extract_ES(hk,s) in   
   (sr,gy,handshakeSecret).

letfun onertt_hs_keys(hk': hashkey', sil:bitstring,handshakeSecret:extracted) = 
   let client_hts = Derive_secret(hk', handshakeSecret,client_hts_label,sil) in    
   let server_hts = Derive_secret(hk', handshakeSecret,server_hts_label,sil) in
   let client_hk = HKDF_expand_label(key2extracted(client_hts),hke_label,empty_bytes) in
   let server_hk = HKDF_expand_label(key2extracted(server_hts),hke_label,empty_bytes) in
   let cfk = HKDF_expand_label(key2extracted(client_hts),fin_label,empty_bytes) in
   let sfk = HKDF_expand_label(key2extracted(server_hts),fin_label,empty_bytes) in
   let masterSecret = HKDF_extract_zero(handshakeSecret) in
   (client_hk, server_hk, cfk, sfk, masterSecret).

letfun send_server_certificate_verify(scl:bitstring,sk:skey) = 
   new s: seed;
   sign(sk,scl,s).

letfun send_server_finished(scvl:bitstring,sfk:key) = 
   mac(sfk,scvl).

letfun onertt_data_keys(hk': hashkey', masterSecret: extracted, sfl:bitstring) = 
   let client_ts0 = Derive_secret(hk', masterSecret,client_ts_label,sfl) in
   let server_ts0 = Derive_secret(hk', masterSecret,server_ts_label,sfl) in
   let client_dk = HKDF_expand_label(key2extracted(client_ts0),dk_label,empty_bytes) in
   let server_dk = HKDF_expand_label(key2extracted(server_ts0),dk_label,empty_bytes) in
   (client_dk, server_dk).

letfun check_client_finished_no_auth(sfl:bitstring,cfin:bitstring,cfk:key) = 
   if mac(cfk,sfl) = cfin then
      true
   else false.

(*
letfun check_client_finished_client_auth(sfl:serverFinishedLogInfo, 
				    certC:certificate,
				    cv:bitstring,cfin:bitstring,
			    	    cfk:key,log1:bitstring,log2:bitstring) = 
   let ccl = ClientCertificateLogInfo(sfl,certC) in
   let ccvl = ClientCertificateVerifyLogInfo(ccl,cv) in
   if (getClientCertificateLogInfo(log1) = ccl &&
       verify(certC,log1,cv) &&
       getClientCertificateVerifyLogInfo(log2) = ccvl &&
       mac(cfk,log2) = cfin) then
      true
   else false.
*)

param N1,N5,N6,
      N7,N8,N9,N10,N11,N12,
      N13,N14,N15,N16.

let Client = 
!N1
    (in(io1,());
    let (cr:nonce,x:key,gx:elt) = send_client_hello() in
    (* for 0-rtt  insert clientEphemeralKeys(cr,x,gx); *)
    out(io2,ClientHello(cr,gx));
    in(io3,ServerHelloIn(sr,gy,l));
    let sil = ServerHelloLogInfo(cr,gx,sr,gy,l) in
    let (masterSecret:extracted,client_hk:key,server_hk:key,cfk:key,sfk:key,=true) = recv_server_hello(hk,hk',sil,x) in
    out(io4,(client_hk, server_hk));
    in(io5,ServerFinishedIn(cert,s,m,log1)); 
    let (client_dk:key,server_dk:key,=true) = recv_server_finished(hk',sil,masterSecret,sfk,cert,s,m,log1) in   
    let scl = ServerCertificateLogInfo(sil,cert,log1) in
    let scvl = ServerCertificateVerifyLogInfo(scl,s) in
    let sfl = ServerFinishedLogInfo(scvl,m) in
    let cfin = send_client_finished_no_auth(sfl,cfk) in
    insert oneRTTClientDataKey(cr,sr,anon_cert,cert,client_dk,server_dk);
    out(io6,ClientFinishedOut(cfin));
    in(io7,());
    if defined(corrupted) then 
       out(io8, (client_dk,server_dk))
    else if cert = pkS then
    (* The client is talking to the honest server.
       Check that the shared key is secret. *)
       (event ClientTerm(cr,gx,sr,gy,client_hk,server_hk,cfk,sfk,client_dk,server_dk);
	let client_dk_secret: key = client_dk in
	let server_dk_secret: key = server_dk)
    else 
       out(io8, (client_dk, server_dk)))
(*|
!N2
   (in(io,());
    let (cr:nonce,x:key,gx:elt) = send_client_hello() in
    out(io,ClientHello(cr,gx));
    in(io,ServerHelloIn(sr,gy,l));
    let sil = ServerHelloLogInfo(cr,gx,sr,gy) in
    let (xES:extracted,hk:key,=true) = recv_server_hello(sil,x,l) in
    out(io,());
    in(io,ServerFinishedIn(cert,s,m,log1,log2,log3)); 
    let (dk:key,cfk:key,=true) = recv_server_finished(sil,xES,xES,cert,s,m,log1,log2,log3) in   
    out(io,());
    in(io,ServerCertificateIn(certC,log4));
    get clientLongTermKeys(=certC,sk) in
    let scl = ServerCertificateLogInfo(sil,cert) in
    let scvl = ServerCertificateVerifyLogInfo(scl,s) in
    let sfl = ServerFinishedLogInfo(scvl,m) in
    let ccl = ClientCertificateLogInfo(sfl,certC) in
    let (sg:bitstring,=true) = send_client_certificate_verify(ccl,sk,log4) in
    out(io,ClientCertificateVerifyOut(sg));
    in(io,log5:bitstring);
    let ccvl = ClientCertificateVerifyLogInfo(ccl,sg) in
    let (cfin:bitstring,=true) = send_client_finished_client_auth(ccvl,cfk,log5) in
    insert oneRTTClientDataKey(cr,sr,certC,cert,dk);
    out(io,ClientFinishedOut(cfin)))
|
!N3
  (in(io,e:bitstring);
   get oneRTTClientDataKey(cr,sr,certC,certS,k) in
   let m = dec(k,e) in
   event RecvClient(cr,sr,certC,certS,m))
| 
!N4
  (in(io,m:bitstring);
   get oneRTTClientDataKey(cr,sr,certC,certS,k) in
   event SendClient(cr,sr,certC,certS,m);
   out(io,enc(k,m)))
  | 
  !N5
  (in(io,());
   get oneRTTClientDataKey(cr,sr,certC,certS,k) in
   event SendClient(cr,sr,certC,certS,secret_msg2);
    out(io,enc(k,secret_msg2)))
*)
.


let Server = 
 !N6
  (in(io9,ClientHello(cr,gx));
   let (sr:nonce,gy:elt,handshakeSecret:extracted) = recv_client_hello(hk,cr,gx) in
   out(io10,ServerHelloOut(sr,gy));
   in(io11,log_rest:bitstring);
   let sil = ServerHelloLogInfo(cr,gx,sr,gy,log_rest) in
   let (client_hk:key, server_hk: key, cfk: key, sfk: key, masterSecret: extracted) = onertt_hs_keys(hk',sil,handshakeSecret) in
   out(io12,(client_hk, server_hk));
   in(io13,(cert:certificate,log1:bitstring));
   get serverLongTermKeys(=cert,sk) in
   let scl = ServerCertificateLogInfo(sil,cert,log1) in
   let sg = send_server_certificate_verify(scl,sk) in
   let scvl = ServerCertificateVerifyLogInfo(scl,sg) in
   let m = send_server_finished(scvl,sfk) in
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let (client_dk: key, server_dk: key) = onertt_data_keys(hk',masterSecret,sfl) in
   event ServerAccept(cr,gx,sr,gy,client_hk,server_hk,cfk,sfk,client_dk,server_dk);
   insert oneRTTServerFalseStartKey(cr,sr,cert,client_dk,server_dk,cfk,sfk,empty_bytes);
   out(io18,(ServerCertificateVerifyOut(sg), ServerFinishedOut(m)));
   in(io19,ClientFinishedIn(cfin:bitstring));
   if check_client_finished_no_auth(sfl,cfin,cfk) then
   insert oneRTTServerDataKey(cr,sr,anon_cert,cert,client_dk,server_dk))
(*|
 !N7
   (in(io,ClientHello(cr,gx));
   let (sr:nonce,gy:elt,xES:extracted) = recv_client_hello(cr,gx) in
   out(io,ServerHelloOut(sr,gy));
   in(io,log:bitstring);
   let sil = ServerHelloLogInfo(cr,gx,sr,gy) in
   let (hk:key,=true) = onertt_hs_keys(sil,xES,log) in
   out(io,hk);
   in(io,(cert:certificate,log1:bitstring));
   get serverLongTermKeys(=cert,sk,gss,ss) in
   let scl = ServerCertificateLogInfo(sil,cert) in
   let (sg:bitstring,=true) = send_server_certificate_verify(scl,sk,log1) in
   out(io,ServerCertificateVerifyOut(sg));
   in(io,log2:bitstring);
   let scvl = ServerCertificateVerifyLogInfo(scl,sg) in
   let (cfk:key,ts0:key,m:bitstring,=true) = send_server_finished(scvl,xES,xES,log2) in
   out(io,ServerFinishedOut(m));
   in(io,log3:bitstring);
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let (dk:key,=true) = onertt_data_keys(sfl,ts0,log3) in
   insert oneRTTServerFalseStartKey(cr,sr,cert,dk,cfk,empty_bytes);
   out(io,());
   in(io,ClientFinishedAuthIn(certC,cv,cfin,log4,log5));
   let ccl = ClientCertificateLogInfo(sfl,certC) in
   if (check_client_finished_client_auth(sfl,certC,cv,cfin,cfk,log4,log5)) then
   insert oneRTTServerDataKey(cr,sr,certC,cert,dk))
 | 
  !N8 (in(io,e:bitstring);
   get oneRTTServerDataKey(cr,sr,certC,cert,k) in
   let m = dec(k,e) in
   event RecvServer(cr,sr,certC,cert,m))
  | 
  !N9 (in(io,m:bitstring);
   get oneRTTServerFalseStartKey(cr,sr,cert,k,cfk,log) in
   event SendServer0(cr,sr,cert,m);
   out(io,enc(k,m)))
  | 
  !N10 
(in(io,m:bitstring);
   get oneRTTServerFalseStartKey(cr,sr,cert,k,cfk,log) in
   event SendServer0(cr,sr,cert,secret_msg1);
    out(io,enc(k,secret_msg1)))
|
  !N11 (in(io,m:bitstring);
   get oneRTTServerDataKey(cr,sr,certC,cert,k) in
   event SendServer(cr,sr,certC,cert,m);
   out(io,enc(k,m)))
|
  !N12 (in(io,m:bitstring);
   get oneRTTServerDataKey(cr,sr,certC,cert,k) in
   event SendServer(cr,sr,certC,cert,secret_msg3);
   out(io,enc(k,secret_msg3)))
*).

(*
let Server0() = 
 !(in(io,(ClientHello(cr,gx)));
   new sr:nonce;
   let (y:key,gy:key) = dh_keygen() in
   get serverLongTermKeys(cert,sk,gss,ss) in
   let ss = expH_P256(x,gs) in
   let xSS = HKDF_extract(zero_key,ss) in
   let dk0 = HKDF_expand(xSS,dk0_label,log) in
   insert zeroRTTServerKey(cr,anon_cert,certS,gs,dk0);
   let shlog = (ClientHello(cr,gy),ServerHello(sr,gy)) in
   let s = DH_P256(y,gx) in
   let xES = HKDF_extract(zero_key,s) in
   let hk =  HKDF_expand(xES,hk_label,shlog) in    
   insert oneRTTServerHSKey(cr,sr,xES,xSS,hk,certS,shlog);
   out(io,(ServerHello(sr,gy)))
  )
 .
 *)

(* Corruption for forward secrecy *)

let corrupt = 
  in(cCorrupt, ()); 
  let corrupted:bool = true in
  out(cCorrupt, skS).

   


process 
  in(io20,());
  new hk: hashkey; (* Key that models the choice of the random oracle *)
  new hk': hashkey'; (* Key that models the choice of the collision resistant hash function *)
  new kseed:keyseed;
  let skS = skgen(kseed) in
  let pkS = pkcert(kseed) in
  insert serverLongTermKeys(pkS,skS);
  out(io21,(pkS,hk'));
(Client | Server
  |
(!N13 in(io22, (pkx: certificate, skx: skey));
  if pkx <> pkS then
  insert serverLongTermKeys(pkx,skx))
(* !N14 (in(io,());
  new kseed:keyseed;
  let sk = skgen(kseed) in
  let pk = pkcert(kseed) in
  insert clientLongTermKeys(pk,sk);
  out(io,pk))
 |
 (!N16 in(io,(gs:elt,cert:certificate,sg:bitstring));
   let kb = elt2bitstring(gs) in
   if verify(cert,kb,sg) then
   insert clientCache(gs,cert))*)
   | corrupt
   | hashoracle
)
