(* Proving that a SUF-CMA MAC composed with a collision-resistant hash
   is an SUF-CMA MAC.  *)

type key [large, fixed].
type mac_t [large, fixed].
type hash.

proof {
      undo 3; (* needed because CryptoVerif simplifies ma = ma'[j] into a MAC check,
      	      	 and this prevents the proof. *)
      auto
}

(* HMAC is a SUF-CMA MAC *)

proba PHMAC.
expand SUF_CMA_mac_nokgen(key, hash, mac_t, HMAC, HMACcheck, PHMAC).

(* Hash is a collision resistant hash function *)

type hashkey [large,fixed].
proba Phash.
expand CollisionResistant_hash(hashkey, bitstring, hash, Hash, Phash).

(* Define a mac primitive that is the composition of HMAC and Hash *)

letfun mac(hk: hashkey, k: key, m: bitstring) = 
       HMAC(k, Hash(hk, m)).

letfun check(hk: hashkey, k: key, m: bitstring, ma: mac_t) =
       HMACcheck(k, Hash(hk, m), ma).
       
(* Prove equivalence between processLeft and processRight *)

query secret b.

channel start, c1, c2, c3, c4, c5.

param N, N', N3.

let processLeft = 
      !N3 in(c1, ()); new k: key;out(c1, ()); (
	 (!N in(c2, x0: bitstring); out(c2, mac(hk, k, x0))) |
	 (!N' in(c3, (m0: bitstring, ma0: mac_t)); out(c3, check(hk, k, m0, ma0)))).

let processRight = 
      !N3 in(c1, ()); new k: key;out(c1, ()); (
	 (!N in(c2, x: bitstring); let ma':mac_t = mac(hk, k, x) in out(c2, ma')) |
	 (!N' in(c3, (m: bitstring, ma: mac_t)); 
	    find j <= N suchthat defined(x[j], ma'[j]) && (m = x[j]) && ma = ma'[j] then out(c3,true) else out(c3, false))).

process
	in(start, ());
	new b: bool;
	new hk: hashkey; (* This key models the choice of the collision resistant hash function *)
	if b then out(start, ()); processLeft
	     else out(start, ()); processRight
