(* Trying to show that 
Derive_Secret_cets_eems
Derive_Secret_psk_binder_key
HKDF_extract_DHE
are indifferentiable from independent random oracles, but it does not work using CV.*)

type extracted [large, fixed].
type key [large, fixed].
type two_keys [large, fixed].
type label.

(* HMAC is a random oracle *)

define ROM_hash_pair(key, hashinput1, hashinput2, hashoutput, hash) {

param Nh, N, Neq.

fun hash(key, hashinput1, hashinput2):hashoutput.

equiv rom(hash)
      !Nh new k:key;
      	  (!N Ohash(x1:hashinput1, x2:hashinput2) := hash(k,x1,x2),
      	   !Neq Oeq(x1':hashinput1, x2':hashinput2, r':hashoutput) := 
	       r' = hash(k,x1',x2'))
      <=(#Oeq / |hashoutput|)=> [computational]
      !Nh (!N Ohash(x1:hashinput1, x2:hashinput2) := 
              find[unique] j <= N suchthat defined(x1[j],x2[j],r[j]) && x1 = x1[j] && x2 = x2[j] then r[j] else
	      new r:hashoutput; r,
      	   !Neq Oeq(x1':hashinput1, x2':hashinput2, r':hashoutput) := 
              find[unique] j <= N suchthat defined(x1[j],x2[j],r[j]) && x1' = x1[j] && x2' = x2[j] then r' = r[j] else
	      false).

}

type hashkey2 [fixed, large].
expand ROM_hash_pair(hashkey2, extracted, bitstring, key, HMAC).

channel cH.
param qH.

let hashoracle = !qH in(cH, (x1:extracted, x2: bitstring)); out(cH, HMAC(hk2, x1,x2)).

(* Hash is a collision resistant hash function *)

type hashkey [large,fixed].
type hash.
proba Phash.
expand CollisionResistant_hash(hashkey, bitstring, hash, Hash, Phash).

(* Derive_secret(Secret, Label, Messages) =
   HKDF_expand_label(Secret, Label, Hash(Messages), Hash.length) =
   HKDF_expand(Secret, [Hash.length, "TLS 1.3, " + Label, Hash(Messages)], Hash.length) =
   HMAC(Secret, [Hash.length, "TLS 1.3, " + Label, Hash(Messages), 0x00])

We define build_arg(Label, Hash) = [Length, "TLS 1.3, " + Label, Hash, 0x00].
*)

fun build_arg(label, hash): bitstring [compos].

letfun HKDF_expand_label(hk2: hashkey2, Secret: extracted, Label: label, HashValue: hash) =
       HMAC(hk2, Secret, build_arg(Label, HashValue)).

letfun Derive_secret(hk2: hashkey2, hk: hashkey, Secret: extracted, Label: label, Messages: bitstring) = 
       HKDF_expand_label(hk2, Secret, Label, Hash(hk, Messages)).

letfun HKDF_extract(hk2: hashkey2, Salt: extracted, Ikm: bitstring) =
       HMAC(hk2, Salt, Ikm).

fun concat(key, key): two_keys [compos].

param N, N3.

equiv concat
      !N new r1: key; new r2: key; O() := concat(r1, r2)
      <=(0)=>
      !N new r: two_keys; O() := r.

(* Labels *)

const client_ets : label. (* ets = early traffic secret *)
const psk_binder_key : label. (* "external psk binder key" or "resumption psk binder key" *)
const eems : label. (* eems = early exporter master secret *)

(* Concatenation of client_early_traffic_secret and early_exporter_secret *)

letfun Derive_Secret_cets_eems(hk2: hashkey2, hk: hashkey, EarlySecret: extracted, log: bitstring) =
       concat(Derive_secret(hk2, hk, EarlySecret, client_ets, log),
              Derive_secret(hk2, hk, EarlySecret, eems, log)).

(* binder_key *)

const empty_log: bitstring.

letfun Derive_Secret_psk_binder_key(hk2: hashkey2, hk: hashkey, EarlySecret: extracted) =
       Derive_secret(hk2, hk, EarlySecret, psk_binder_key, empty_log).

(* Handshake Secret *)

type elt [large, bounded].
fun elt2bitstring(elt): bitstring [compos].

letfun HKDF_extract_DHE(hk2: hashkey2, EarlySecret: extracted, DHE: elt) =
       HKDF_extract(hk2, EarlySecret, elt2bitstring(DHE)).

forall l: label, h: hash, e: elt; build_arg(l, h) <> elt2bitstring(e).

(* Prove equivalence between processLeft and independent random oracles *)

channel start, c1, c2, c3, c4.

param N', N''.

let processLeft =
     (!N in(c2, (k: extracted, log0: bitstring)); out(c2, Derive_Secret_cets_eems(hk2, hk, k, log0))) |
     (!N' in(c3, k: extracted); out(c3, Derive_Secret_psk_binder_key(hk2, hk, k))) |
     (!N'' in(c4, (k: extracted, DHE0: elt)); out(c4, HKDF_extract_DHE(hk2, k, DHE0))).


process
	in(start, ());
	new hk: hashkey; (* This key models the choice of the collision resistant hash function *)
	new hk2: hashkey2; (* This key models the choice of the random oracle *)
	out(start, ());
	processLeft | hashoracle
	     
