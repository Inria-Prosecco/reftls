channel io.

set interactiveMode = true.

(* 
proof {
      crypto uf_cma(sign) kseed;
      insert 387 "find j' <= N1 suchthat defined(gx_336[j']) && gx_391 = gx_336[j'] then";
      SArename y_397;
      insert 51 "find j <= N6 suchthat defined(y_550[j], gy_398[j], gx_391[j]) && gx_336 = gx_391[j] && gy_340 = gy_398[j] then";
      crypto rom(HKDF_extract_zero);
      remove_assign binder s_351;
      remove_assign binder s_399;
      simplify;
      crypto gdh(exp) "variables: x_335 -> @3_a, y_550 -> @3_b .";
      crypto prf(HKDF_expand) *;
      crypto extractor1(HKDF_extract) *;
      crypto prf(HKDF_expand) *;
      crypto suf_cma(mac) *;
} 
*)

const empty_bytes:bitstring.

type key [large, fixed].
const zero_key: key.

type elt [large, bounded].
fun element2key(elt): key [compos].
fun elt2bitstring(elt): bitstring [compos].

(* Gap Diffie-Hellman assumption. *)


define GDH_prime_order(G, Z, g, exp, mult, pGDH) {

fun exp(G,Z): G.
fun exp'(G,Z): G.
const g:G.

fun mult(Z,Z): Z. 
equation commut(mult).

(* exponents multiply *)

forall a:G, x:Z, y:Z;
  exp(exp(a,x), y) = exp(a, mult(x,y)).
forall a:G, x:Z, y:Z;
  exp'(exp'(a,x), y) = exp'(a, mult(x,y)).

(* injectivity *)

forall x:Z, y:Z; (exp(g,x) = exp(g,y)) = (x = y).
forall x:Z, y:Z; (exp'(g,x) = exp'(g,y)) = (x = y).

(* According to http://link.springer.com/chapter/10.1007%2F11745853_14,
page 214, the order of the base point is a prime
namely 2^252 + 27742317777372353535851937790883648493.
So exp(x,y) = exp(x',y) implies y = y' (provided y is not a multiple
of this prime; if y is a correctly generated secret key, that cannot
happen)
-- TO DO check for TLS what groups are used *)

forall x:G, x':G, y:Z; (exp(x,y) = exp(x',y)) = (x = x').
forall x:G, x':Z, y:Z; (exp(x,y) = exp(g, mult(x',y))) = (x = exp(g,x')).

forall x:G, y:Z, y':Z; (exp(x,y) = exp(x,y')) = (y = y').

(* collision between products *)

collision new x1:Z; new x2:Z; new x3:Z; new x4:Z; 
  mult(x1,x2) = mult(x3,x4) <=(1/|Z|)=> false. 

collision new x1:Z; new x2:Z; 
  mult(x1,x1) = mult(x2,x2) <=(1/|Z|)=> false. 

forall x:Z, y:Z, y':Z; 
  (mult(x,y) = mult(x,y')) = (y = y').

(* replace a random group element with an exponentiation, and conversely *)

param N, N'.

equiv group_to_exp_strict(exp)
      !N new X:G; (OX() := X, !N' OXm(m:Z) [useful_change] := exp(X,m))
<=(0)=> [computational]
      !N new x:Z; (OX() := exp(g,x), !N' OXm(m:Z) := exp(g,mult(x,m))).

(* This equivalence is very general, apply it only manually, because
   otherwise it might be applied too often.  The equivalence above is
   particular case applied only when X is inside exp, and good for
   automatic proofs. *)

equiv group_to_exp(exp)
      !N new X:G; OX() := X 
<=(0)=> [manual, computational]    
      !N new x:Z; OX() := exp(g,x).


equiv exp_to_group(exp)
      !N new x:Z; OX() := exp(g,x)
<=(0)=> [computational]
      !N new X:G; OX() := X.

equiv exp'_to_group(exp)
      !N new x:Z; OX() := exp'(g,x)
<=(0)=> [computational]
      !N new X:G; OX() := X.

(* the GDH assumption
    This equivalence says that, when exp(g,a[i]) and exp(g,b[j]) are known to the
    adversary, the adversary can compute exp(g, mult(a[i], b[j])) only with
    negligible probability, even in the presence of a DDH oracle
    DDH(G,A,B,C) tells whether A = G^a, B = G^b, and C = G^{ab} for some a,b,
    that is DDH(G,A,B,C) is (log_G(A) * log_G(B) = log_G(C)). *) 

const mark: bitstring.

param na, naDDH, naDDH1, naDDH2, naDDH3, naDDH4, naDDH5, naDDH6, naDDH7, naDDH8,
      nb, nbDDH, nbDDH1, nbDDH2, nbDDH3, nbDDH4, nbDDH5, nbDDH6, nbDDH7, nbDDH8.

equiv gdh(exp)
    !na new a:Z; (
      OA() := exp(g,a), 
      Oa() [3] := a,
      !naDDH1 ODDHa1(m:G, m':G) := m = exp(m', a),
      !naDDH2 ODDHa2(m:G,m':G,j<=nb) := exp(m, b[j]) = exp(m',a),
      !naDDH3 ODDHa3(m:G,m':G,j<=na) := exp(m, a[j]) = exp(m',a),
      !naDDH4 ODDHa4(m:G,j'<=nb,j<=nb) := exp(m, b[j]) = exp(g,mult(b[j'],a)),
      !naDDH5 ODDHa5(m:G,j'<=nb,j<=na) := exp(m, a[j]) = exp(g,mult(b[j'],a)),
      !naDDH6 ODDHa6(m:G,j'<=na,j<=nb) := exp(m, b[j]) = exp(g,mult(a[j'],a)),
      !naDDH7 ODDHa7(m:G,j'<=na,j<=na) := exp(m, a[j]) = exp(g,mult(a[j'],a)),
      !naDDH ODDHa(m:G, j<=nb) [useful_change] := m = exp(g, mult(b[j], a)),
      !naDDH8 ODDHa8(m:G,j<=na) [3] := m = exp(g,mult(a[j], a))
    ),
    !nb new b:Z; (
      OB() := exp(g,b),
      Ob() [3] := b,
      !nbDDH1 ODDHb1(m:G, m':G) := m = exp(m', b),
      !nbDDH2 ODDHb2(m:G,m':G,j<=nb) := exp(m, b[j]) = exp(m',b),
      !nbDDH3 ODDHb3(m:G,m':G,j<=na) := exp(m, a[j]) = exp(m',b),
      !nbDDH4 ODDHb4(m:G,j'<=nb,j<=nb) := exp(m, b[j]) = exp(g,mult(b[j'],b)),
      !nbDDH5 ODDHb5(m:G,j'<=nb,j<=na) := exp(m, a[j]) = exp(g,mult(b[j'],b)),
      !nbDDH6 ODDHb6(m:G,j'<=na,j<=nb) := exp(m, b[j]) = exp(g,mult(a[j'],b)),
      !nbDDH7 ODDHb7(m:G,j'<=na,j<=na) := exp(m, a[j]) = exp(g,mult(a[j'],b)),
      !nbDDH ODDHb(m:G, j<=na) := m = exp(g, mult(a[j], b)),
      !nbDDH8 ODDHb8(m:G,j<=nb) [3] := m = exp(g,mult(b[j], b))
    )
<=((#ODDHa + #ODDHa1 + #ODDHa4 + #ODDHa5 + #ODDHb + #ODDHb1 + #ODDHb6 + #ODDHb7) *
	   max(1, 7.4*#Oa) * max(1, 7.4*#Ob) *
	   pGDH(time + (na + nb + #ODDHa + #ODDHa1 + #ODDHb + #ODDHb1) * time(exp),
	   #ODDHa1 + #ODDHa2 + #ODDHa3 + #ODDHa4 + #ODDHa5 + #ODDHa6 + #ODDHa7 + #ODDHa8 +
	   #ODDHb1 + #ODDHb2 + #ODDHb3 + #ODDHb4 + #ODDHb5 + #ODDHb6 + #ODDHb7 + #ODDHb8))=> [computational]
    !na new a:Z [unchanged]; (
      OA() := exp'(g,a), 
      Oa() := let ka:bitstring = mark in a,
      !naDDH1 ODDHa1(m:G, m':G) := if defined(ka) then m = exp'(m', a) else 
      		  	   find u<=nb suchthat defined(b[u],kb[u]) && m' = exp'(g,b[u]) then m = exp'(m', a) else
			   find u<=nb suchthat defined(b[u]) && m' = exp'(g,b[u]) then false else
                               (* by CDH, if neither a nor b[u] are leaked, then m = exp(g, b[u]*a) is impossible *)
			   m = exp'(m', a)
			       (* GDH allows to compute m = exp(m',a) for any m and m', without leaking a, 
			          as it is DDH(g, exp(g,a), m', m) *),
      !naDDH2 ODDHa2(m:G,m':G,j<=nb) := exp'(m, b[j]) = exp'(m',a),
      	   (* GDH allows to compute exp(m, b[j]) = exp(m',a) for any m and m', 
	      without leaking a, as it is DDH(exp(g,a), exp(g,b[j]), m, m')
	      Indeed, 
 	      D(exp(g,a),exp(g,b[j]),m,m') 
      	        = (log_{g^a}(g^b[j]) * log_{g^a}(m) = log_{g^a}(m'))
      		= (b[j]/a * log_g(m)/a = log_g(m')/a)
      		= (b[j] * log_g(m) = a log_g(m'))
      		= (m^b[j] = m'^a). *)
      !naDDH3 ODDHa3(m:G,m':G,j<=na) := exp'(m, a[j]) = exp'(m',a),
      	    (* Similar to ODDHa2 *)
      !naDDH4 ODDHa4(m:G,j'<=nb,j<=nb) :=
      	      find u<=nb suchthat defined(kb[u],b[u]) && b[j'] = b[u] then exp'(m, b[j]) = exp'(g,mult(b[j'],a)) else
	      if defined(ka) then exp'(m, b[j]) = exp'(g,mult(b[j'],a)) else
      	      b[j] = b[j'] && m = exp'(g,a),
      !naDDH5 ODDHa5(m:G,j'<=nb,j<=na) :=
      	      find u<=nb suchthat defined(kb[u],b[u]) && b[j'] = b[u] then exp'(m, a[j]) = exp'(g,mult(b[j'],a)) else
	      if defined(ka) then exp'(m, a[j]) = exp'(g,mult(b[j'],a)) else
      	      a[j] = a && m = exp'(g,b[j']),
      !naDDH6 ODDHa6(m:G,j'<=na,j<=nb) := exp'(m, b[j]) = exp'(g,mult(a[j'],a)),
      !naDDH7 ODDHa7(m:G,j'<=na,j<=na) := exp'(m, a[j]) = exp'(g,mult(a[j'],a)),
            (* ODDHa4..7 are particular cases of ODDHa2 or ODDHa3, with m' = exp(g, b[j'])
	       or m' = exp(g, a[j']).
	       We need to consider all these forms because CryptoVerif rewrites
	       exp(exp(g,b[j']),a) into exp(g,mult(b[j'],a)), and it would not
	       detect exp(g,mult(b[j'],a)) as an instance of exp(m',a). *)
      !naDDH ODDHa(m:G, j<=nb) :=
      	     find u<=nb suchthat defined(kb[u],b[u]) && b[j] = b[u] then m = exp'(g, mult(b[j], a)) else 
             if defined(ka) then m = exp'(g, mult(b[j], a)) else false,
	    (* ODDHa is a particular case of ODDHa1 in which can apply the CDH assumption,
	       provided a and b[j] are not leaked. *)
      !naDDH8 ODDHa8(m:G,j<=na) := m = exp'(g,mult(a[j], a))
            (* ODDHa8 is a particular case of ODDHa1 in which we do not apply
	       the CDH assumption, since we apply it between a's and b's *)
    ),
    !nb new b:Z [unchanged]; (
      OB() := exp'(g,b), 
      Ob() := let kb:bitstring = mark in b,
      !nbDDH1 ODDHb1(m:G, m':G) := if defined(kb) then m = exp'(m', b) else 
      		  	   find u<=na suchthat defined(a[u],ka[u]) && m' = exp'(g,a[u]) then m = exp'(m', b) else
      		  	   find u<=na suchthat defined(a[u]) && m' = exp'(g,a[u]) then false else
                               (* by CDH, if neither a nor b[u] are leaked, then m = exp(g, a[u]*b) is impossible *)
			   m = exp'(m', b)
			       (* GDH allows to compute m = exp(m',a) for any m and m', without leaking a *),
      !nbDDH2 ODDHb2(m:G,m':G,j<=nb) := exp'(m, b[j]) = exp'(m',b),
      !nbDDH3 ODDHb3(m:G,m':G,j<=na) := exp'(m, a[j]) = exp'(m',b),
      !nbDDH4 ODDHb4(m:G,j'<=nb,j<=nb) := exp'(m, b[j]) = exp'(g,mult(b[j'],b)),
      !nbDDH5 ODDHb5(m:G,j'<=nb,j<=na) := exp'(m, a[j]) = exp'(g,mult(b[j'],b)),
      !nbDDH6 ODDHb6(m:G,j'<=na,j<=nb) :=
      	      find u<=na suchthat defined(ka[u],a[u]) && a[j'] = a[u] then exp'(m, b[j]) = exp'(g,mult(a[j'],b)) else
	      if defined(kb) then exp'(m, b[j]) = exp'(g,mult(a[j'],b)) else
      	      b[j] = b && m = exp'(g,a[j']),
      !nbDDH7 ODDHb7(m:G,j'<=na,j<=na) :=
      	      find u<=na suchthat defined(ka[u],a[u]) && a[j'] = a[u] then exp'(m, a[j]) = exp'(g,mult(a[j'],b)) else
	      if defined(kb) then exp'(m, a[j]) = exp'(g,mult(a[j'],b)) else
      	      a[j] = a[j'] && m = exp'(g,b),
      !nbDDH ODDHb(m:G, j<=na) := find u<=na suchthat defined(ka[u],a[u]) && a[j] = a[u] then m = exp'(g, mult(a[j], b)) else 
                            if defined(kb) then m = exp'(g, mult(a[j], b)) else false,
      !nbDDH8 ODDHb8(m:G,j<=nb) := m = exp'(g,mult(b[j], b))
    ).

    (* We need to consider both forms m = exp(m', a) and m = exp(g,
    mult(b[j], a)) in the equivalence, because, when m' is known to be
    exp(g, b[j]), CryptoVerif is going to simplify m = exp(m', a) into
    m = exp(g, mult(b[j], a)), and the procedure that tests whether a
    term in the game matches a term in the equivalence would not
    recognize that m = exp(g, mult(b[j], a)) in the game matches m =
    exp(m', a) in the equivalence. *)

}


proba pGDH.
expand GDH_prime_order(elt, key, G, exp, mult, pGDH).

letfun dh_keygen() =
   new x:key;
   (x,exp(G,x)).

(* Labels for HKDF_expand *)

type label.
const hk_label:label.
const ss_label:label.
const es_label:label.
const cfin_label:label.
const sfin_label:label.
const ts_label:label.
const dk_label:label.
const dk0_label:label.

type extracted [large, fixed].
(* In fact, the function key2extracted is the identity *)
fun key2extracted(key):extracted [compos]. 

param N, N2, N3, N4.

equiv id(key2extracted)
      !N new k:key; Ok() := key2extracted(k)
  <=(0)=>
      !N new e:extracted; Ok():= e.

type hashkey [large,fixed].

expand ROM_hash(hashkey, elt, extracted, HKDF_extract_zero).

param qH [noninteractive].
channel c1, c2.
let hashoracle = ! qH in(c1, x:elt); out(c2, HKDF_extract_zero(hk,x)). 

(* HKDF_extract is an entropy extractor.
   The first argument is the salt, the second argument
   is the key material *)

fun HKDF_extract(key,key):extracted.

proba Pextract1.

equiv extractor1(HKDF_extract)
       !N3 new r: key; !N Of(x:key) := HKDF_extract(x, r)
     <=(N3 * Pextract1(time + (N3-1)*(N * time(HKDF_extract, maxlength(x))), N, maxlength(x)))=>
       !N3 !N Of(x:key) :=
		find[unique] j<=N suchthat defined(x[j],r2[j]) && x = x[j] then r2[j] 
		else new r2: extracted; r2.

proba Pextract2.

equiv extractor2(HKDF_extract)
       !N3 new r: elt; !N Of(x:key) := HKDF_extract(x, element2key(r))
     <=(N3 * Pextract2(time + (N3-1)*(N * time(HKDF_extract, maxlength(x))), N, maxlength(x)))=>
       !N3 !N Of(x:key) :=
		find[unique] j<=N suchthat defined(x[j],r2[j]) && x = x[j] then r2[j] 
		else new r2: extracted; r2.

(* HKDF_expand is a pseudo random function *)

fun HKDF_expand(extracted,label,bitstring):key.

proba Pprf.

equiv prf(HKDF_expand)
       !N3 new r: extracted; !N Of(x:label, y:bitstring) := HKDF_expand(r, x, y)
     <=(N3 * Pprf(time + (N3-1)*(N * time(HKDF_expand, maxlength(x), maxlength(y))), N, maxlength(x), maxlength(y)))=>
       !N3 !N Of(x:label, y:bitstring) :=
		find[unique] j<=N suchthat defined(x[j],y[j],r2[j]) && x = x[j] && y = y[j] then r2[j] 
		else new r2: key; r2.

(* SUF-CMA MAC *)

define SUF_CMA_mac_nokgen(mkey, macinput, macres, mac, check, Pmac) {

fun mac(mkey, macinput):macres.
fun check(mkey, macinput, macres): bool.

fun mac2(mkey, macinput):macres.

forall m:macinput, k:mkey;
	check(k, m, mac(k, m)).

forall m:macinput, k:mkey, m':macres;
	(mac(k,m) = m') = check(k, m, m').

equiv suf_cma(mac)
      ! N3 new k: mkey;(
	 !N Omac(x: macinput) := mac(k, x),
	 !N2 Ocheck(m: macinput, ma: macres) := check(k, m, ma))
     <=(N3 * Pmac(time + (N3-1)*(N*time(mac,maxlength(x)) + N2*time(check,maxlength(m),maxlength(ma))), N, N2, max(maxlength(x), maxlength(m))))=> [computational]
      ! N3 new k: mkey [unchanged];(
	 !N Omac(x: macinput) := let ma2:macres = mac2(k, x) in ma2,
	 !N2 Ocheck(m: macinput, ma: macres) := 
	    find j <= N suchthat defined(x[j], ma2[j]) && (m = x[j]) && ma = ma2[j] then true else false).

}

proba Pmac.
expand SUF_CMA_mac_nokgen(key, bitstring, bitstring, mac, check, Pmac).

fun enc(key,bitstring): bitstring.
fun dec(key,bitstring): bitstring.
forall k:key, m:bitstring;
    dec(k,enc(k,m)) = m.

type certificate [bounded].
const anon_cert:certificate.

(* UF-CMA signatures
   I suppose that signatures are probabilistic, and
   I generate the public key and private key from a common seed
   (instead of generating the public key from the private key).
   Verify returns true when the verification succeeds 
   (instead of returning the message) *)

define UF_CMA_signature_key_first(keyseed, pkey, skey, signinput, signature, seed, skgen, pkgen, sign, check, Psign, Psigncoll) {

const mark: bitstring.

fun sign(skey, signinput, seed): signature.
fun skgen(keyseed):skey.
fun pkgen(keyseed):pkey.
fun check(pkey, signinput, signature): bool.

fun sign2(skey, signinput, seed): signature.
fun skgen2(keyseed):skey.
fun pkgen2(keyseed):pkey.
fun check2(pkey, signinput, signature): bool.

forall m:signinput, r:keyseed, r2:seed; 
	check(pkgen(r), m, sign(skgen(r), m, r2)) = true.
forall m:signinput, r:keyseed, r2:seed; 
	check2(pkgen2(r), m, sign2(skgen2(r), m, r2)) = true.

equiv uf_cma(sign)
       !N3 new r: keyseed; (Opk() [2] := pkgen(r),
			    !N2 new r2: seed; Osign(x: signinput) := sign(skgen(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) := check(pkgen(r), m1, si1)),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) [3] := check(y, m, si) [all]
     <=(N3 * Psign(time + (N4+N-1) * time(check, max(maxlength(m1), maxlength(m)), max(maxlength(si1), maxlength(si))) + (N3-1)*(time(pkgen) + time(skgen) + N2 * time(sign, maxlength(x)) + N * time(check, maxlength(m1), maxlength(si1))), N2, maxlength(x)))=> [computational]
       !N3 new r: keyseed [unchanged]; 
       	       	  	   (Opk() := pkgen2(r),
			    !N2 new r2: seed [unchanged]; Osign(x: signinput) := sign2(skgen2(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) :=
                              find j <= N2 suchthat defined(x[j]) && m1 = x[j] && check2(pkgen2(r), m1, si1) then true else false),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) :=
		find j <= N2, k <= N3 suchthat defined(x[j,k],r[k]) && y = pkgen2(r[k]) && m = x[j,k] && check2(y, m, si) then true else
		find k <= N3 suchthat defined(r[k]) && y = pkgen2(r[k]) then false else
		check(y,m,si).

equiv uf_cma_corrupt(sign)
       !N3 new r: keyseed; (Opk() [useful_change] [2] := pkgen(r),
			    !N2 new r2: seed; Osign(x: signinput) [useful_change] := sign(skgen(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) [useful_change] := check(pkgen(r), m1, si1),
			    Ocorrupt() [10] := r),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) [3] := check(y, m, si) [all]
     <=(N3 * Psign(time + (N4+N-1) * time(check, max(maxlength(m1), maxlength(m)), max(maxlength(si1), maxlength(si))) + (N3-1)*(time(pkgen) + time(skgen) + N2 * time(sign, maxlength(x)) + N * time(check, maxlength(m1), maxlength(si1))), N2, maxlength(x)))=> [manual,computational]
       !N3 new r: keyseed [unchanged]; 
       	       	  	   (Opk() := pkgen2(r),
			    !N2 new r2: seed [unchanged]; Osign(x: signinput) := sign2(skgen2(r), x, r2),
			    !N Ocheck(m1: signinput, si1:signature) :=
			      if defined(corrupt) then check2(pkgen2(r), m1, si1) else
                              find j <= N2 suchthat defined(x[j]) && m1 = x[j] && check2(pkgen2(r), m1, si1) then true else false,
			    Ocorrupt() := let corrupt: bitstring = mark in r),
       !N4 Ocheck2(m: signinput, y: pkey, si: signature) :=
		find k <= N3 suchthat defined(r[k],corrupt[k]) && y = pkgen2(r[k]) then check2(y, m, si) else
		find j <= N2, k <= N3 suchthat defined(x[j,k],r[k]) && y = pkgen2(r[k]) && m = x[j,k] && check2(y, m, si) then true else
		find k <= N3 suchthat defined(r[k]) && y = pkgen2(r[k]) then false else
		check(y,m,si).

collision new r1:keyseed; new r2:keyseed; 
	pkgen(r1) = pkgen(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	pkgen(r1) = pkgen2(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	pkgen2(r1) = pkgen2(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	skgen(r1) = skgen(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	skgen(r1) = skgen2(r2) <=(Psigncoll)=> false.
collision new r1:keyseed; new r2:keyseed; 
	skgen2(r1) = skgen2(r2) <=(Psigncoll)=> false.

}

type keyseed [large, bounded].
type seed [large, bounded].
type skey [bounded].
proba Psign.
proba Psigncoll.
expand UF_CMA_signature_key_first(keyseed, certificate, skey, bitstring, bitstring, seed, 
       		        skgen, pkcert, sign, verify, Psign, Psigncoll).

type nonce [large, fixed].

(* Message formats *)

fun ClientHello(nonce, elt): bitstring [compos].
fun ServerHelloIn(nonce, elt, bitstring): bitstring [compos].
fun ServerHelloOut(nonce, elt): bitstring [compos].
fun ServerCertificateIn(certificate,bitstring): bitstring [compos].
fun ServerFinishedIn(certificate,bitstring,bitstring,bitstring,bitstring,bitstring): bitstring [compos].
fun ServerCertificateVerifyOut(bitstring): bitstring [compos].
fun ServerFinishedOut(bitstring): bitstring [compos].

fun ClientCertificateVerifyOut(bitstring): bitstring [compos].
fun ClientFinishedOut(bitstring): bitstring  [compos].
fun ClientFinishedIn(bitstring,bitstring): bitstring  [compos].
fun ClientFinishedAuthIn(certificate,bitstring,bitstring,bitstring,bitstring): bitstring  [compos].

(* Logs *)

type serverHelloLogInfo.
fun ServerHelloLogInfo(nonce,elt,nonce,elt): serverHelloLogInfo [compos].
fun getServerHelloLogInfo(bitstring): serverHelloLogInfo [decompos].

type serverCertificateLogInfo.
fun ServerCertificateLogInfo(serverHelloLogInfo,certificate): serverCertificateLogInfo [compos].
fun getServerCertificateLogInfo(bitstring): serverCertificateLogInfo [decompos].

type serverCertificateVerifyLogInfo.
fun ServerCertificateVerifyLogInfo(serverCertificateLogInfo,bitstring): serverCertificateVerifyLogInfo [compos].
fun getServerCertificateVerifyLogInfo(bitstring): serverCertificateVerifyLogInfo [decompos].

type serverFinishedLogInfo.
fun ServerFinishedLogInfo(serverCertificateVerifyLogInfo,bitstring): serverFinishedLogInfo [compos].
fun getServerFinishedLogInfo(bitstring): serverFinishedLogInfo [decompos].

type clientCertificateLogInfo.
fun ClientCertificateLogInfo(serverFinishedLogInfo,certificate): clientCertificateLogInfo [compos].
fun getClientCertificateLogInfo(bitstring): clientCertificateLogInfo [decompos].

type clientCertificateVerifyLogInfo.
fun ClientCertificateVerifyLogInfo(clientCertificateLogInfo,bitstring): clientCertificateVerifyLogInfo [compos].
fun getClientCertificateVerifyLogInfo(bitstring): clientCertificateVerifyLogInfo [decompos].

table serverLongTermKeys(certificate,skey,elt,key).
table clientLongTermKeys(certificate,skey).
table clientCache(elt,certificate).

table oneRTTClientDataKey(nonce,nonce,certificate,certificate,key).
table oneRTTServerDataKey(nonce,nonce,certificate,certificate,key).
table oneRTTServerFalseStartKey(nonce,nonce,certificate,key,key,bitstring).
table zeroRTTClientKey(nonce,certificate,certificate,key,key).
table zeroRTTServerKey(nonce,certificate,certificate,key,key).


event SendClient(nonce,nonce,certificate,certificate,bitstring).
event RecvServer(nonce,nonce,certificate,certificate,bitstring).
event SendServer(nonce,nonce,certificate,certificate,bitstring).
event RecvClient(nonce,nonce,certificate,certificate,bitstring).

event SendClient0(nonce,certificate,certificate,key,bitstring).
event RecvServer0(nonce,certificate,certificate,key,bitstring).
event SendServer0(nonce,nonce,certificate,bitstring).
event RecvClient0(nonce,nonce,certificate,bitstring).


(* Secrecy properties *)

query secret dk_secret.

const secret_msg0:bitstring.
const secret_msg1:bitstring.
const secret_msg2:bitstring.
const secret_msg3:bitstring.

letfun send_client_hello() = 
       new cr:nonce;
       new x:key;
       let gx = exp(G,x) in
       (cr,x,gx).


letfun recv_server_hello(hk: hashkey, sil:serverHelloLogInfo, x:key, l:bitstring) = 
  let ServerHelloLogInfo(cr,gx,sr,gy) = sil in
  (let s = exp(gy,x) in
   let xES = HKDF_extract_zero(hk,s) in
   let hk =  HKDF_expand(xES,hk_label,l) in    
   if getServerHelloLogInfo(l) = ServerHelloLogInfo(cr,gx,sr,gy) 
   then (xES,hk,true)
   else (xES,hk,false))
  else (key2extracted(zero_key),zero_key,false).
   

letfun recv_server_finished(si:serverHelloLogInfo, xES:extracted, xSS:extracted,
       		            cert:certificate, s:bitstring, m:bitstring, 
			    log1:bitstring, log2:bitstring, log3:bitstring) =
   let mES = HKDF_expand(xES,es_label,log2) in
   let mSS = HKDF_expand(xSS,ss_label,log2) in
   let ms = HKDF_extract(mSS,mES) in
   let cfk = HKDF_expand(ms,cfin_label,empty_bytes) in
   let sfk = HKDF_expand(ms,sfin_label,empty_bytes) in
   let ts0 = HKDF_expand(ms,ts_label,log2) in
   let dk = HKDF_expand(key2extracted(ts0),dk_label,log3) in
   let scl = ServerCertificateLogInfo(si,cert) in
   let scvl = ServerCertificateVerifyLogInfo(scl,s) in
   let sfl = ServerFinishedLogInfo(scvl,m) in
   if (verify(cert,log1,s) &&
       mac(sfk,log2) = m &&
       getServerCertificateLogInfo(log1) = scl &&
       getServerCertificateVerifyLogInfo(log2) = scvl &&
       getServerFinishedLogInfo(log3) = sfl) then
       (dk,cfk,true)
   else (dk,cfk,false).
			   
letfun send_client_finished_no_auth(sfl:serverFinishedLogInfo, cfk:key, log3: bitstring) = 
   let cfin = mac(cfk,log3) in			    
   if getServerFinishedLogInfo(log3) = sfl then
        (cfin,true)
   else (cfin,false).

letfun send_client_certificate_verify(ccl:clientCertificateLogInfo, sk:skey, log:bitstring) = 
   new s: seed;
   let sg = sign(sk,log,s) in
   if getClientCertificateLogInfo(log) = ccl then
        (sg,true)
   else (sg,false).

letfun send_client_finished_client_auth(ccvl:clientCertificateVerifyLogInfo, cfk:key, log3: bitstring) = 
   let cfin = mac(cfk,log3) in			    
   if getClientCertificateVerifyLogInfo(log3) = ccvl then
        (cfin,true)
   else (cfin,false).

letfun recv_client_hello(hk: hashkey, cr:nonce, gx:elt) = 
   new sr:nonce;
   new y: key;
   let gy = exp(G,y) in
   let s = exp(gx,y) in
   let xES = HKDF_extract_zero(hk,s) in
   (sr,gy,xES).

letfun onertt_hs_keys(sil:serverHelloLogInfo,xES:extracted,log:bitstring) = 
   let hk = HKDF_expand(xES,hk_label,log) in    
   if getServerHelloLogInfo(log) = sil then
      (hk,true)
   else (hk,false).

letfun send_server_certificate_verify(scl:serverCertificateLogInfo,sk:skey,log:bitstring) = 
   new s: seed;
   let sg = sign(sk,log,s) in
   if getServerCertificateLogInfo(log) = scl then
      (sg,true)
   else (sg,false).

letfun send_server_finished(scvl:serverCertificateVerifyLogInfo,xES:extracted,xSS:extracted,log:bitstring) = 
   let mES = HKDF_expand(xES,es_label,log) in
   let mSS = HKDF_expand(xSS,ss_label,log) in
   let ms = HKDF_extract(mSS,mES) in
   let cfk = HKDF_expand(ms,cfin_label,empty_bytes) in
   let sfk = HKDF_expand(ms,sfin_label,empty_bytes) in
   let ts0 = HKDF_expand(ms,ts_label,log) in
   let m = mac(sfk,log) in
   if getServerCertificateVerifyLogInfo(log) = scvl then
      (cfk,ts0,m,true)
   else (cfk,ts0,m,false).

letfun onertt_data_keys(sfl:serverFinishedLogInfo,ts0:key,log:bitstring) = 
   let dk = HKDF_expand(key2extracted(ts0),dk_label,log) in
   if getServerFinishedLogInfo(log) = sfl then
      (dk,true)
   else (dk,false).

letfun check_client_finished_no_auth(sfl:serverFinishedLogInfo,cfin:bitstring,cfk:key,log:bitstring) = 
   if (mac(cfk,log) = cfin && 
       getServerFinishedLogInfo(log) = sfl) then
      true
   else false.

letfun check_client_finished_client_auth(sfl:serverFinishedLogInfo, 
				    certC:certificate,
				    cv:bitstring,cfin:bitstring,
			    	    cfk:key,log1:bitstring,log2:bitstring) = 
   let ccl = ClientCertificateLogInfo(sfl,certC) in
   let ccvl = ClientCertificateVerifyLogInfo(ccl,cv) in
   if (getClientCertificateLogInfo(log1) = ccl &&
       verify(certC,log1,cv) &&
       getClientCertificateVerifyLogInfo(log2) = ccvl &&
       mac(cfk,log2) = cfin) then
      true
   else false.

param N1,N5,N6,
      N7,N8,N9,N10,N11,N12,
      N13,N14,N15,N16.

let Client = 
!N1
    (in(io,());
    let (cr:nonce,x:key,gx:elt) = send_client_hello() in
    (* for 0-rtt  insert clientEphemeralKeys(cr,x,gx); *)
    out(io,ClientHello(cr,gx));
    in(io,ServerHelloIn(sr,gy,l));
    let sil = ServerHelloLogInfo(cr,gx,sr,gy) in
    let (xES:extracted,hk:key,=true) = recv_server_hello(hk,sil,x,l) in
    out(io,hk);
    in(io,ServerFinishedIn(cert,s,m,log1,log2,log3:bitstring)); 
    let (dk:key,cfk:key,=true) = recv_server_finished(sil,xES,xES,cert,s,m,log1,log2,log3) in   
    let scl = ServerCertificateLogInfo(sil,cert) in
    let scvl = ServerCertificateVerifyLogInfo(scl,s) in
    let sfl = ServerFinishedLogInfo(scvl,m) in
    let (cfin:bitstring,=true) = send_client_finished_no_auth(sfl,cfk,log3) in
    insert oneRTTClientDataKey(cr,sr,anon_cert,cert,dk);
    out(io,ClientFinishedOut(cfin));
    in(io,());
    if cert = pkS then
    (* The client is talking to the honest server.
       Check that the shared key is secret. *)
    let dk_secret: key = dk)
(*|
!N2
   (in(io,());
    let (cr:nonce,x:key,gx:elt) = send_client_hello() in
    out(io,ClientHello(cr,gx));
    in(io,ServerHelloIn(sr,gy,l));
    let sil = ServerHelloLogInfo(cr,gx,sr,gy) in
    let (xES:extracted,hk:key,=true) = recv_server_hello(sil,x,l) in
    out(io,());
    in(io,ServerFinishedIn(cert,s,m,log1,log2,log3)); 
    let (dk:key,cfk:key,=true) = recv_server_finished(sil,xES,xES,cert,s,m,log1,log2,log3) in   
    out(io,());
    in(io,ServerCertificateIn(certC,log4));
    get clientLongTermKeys(=certC,sk) in
    let scl = ServerCertificateLogInfo(sil,cert) in
    let scvl = ServerCertificateVerifyLogInfo(scl,s) in
    let sfl = ServerFinishedLogInfo(scvl,m) in
    let ccl = ClientCertificateLogInfo(sfl,certC) in
    let (sg:bitstring,=true) = send_client_certificate_verify(ccl,sk,log4) in
    out(io,ClientCertificateVerifyOut(sg));
    in(io,log5:bitstring);
    let ccvl = ClientCertificateVerifyLogInfo(ccl,sg) in
    let (cfin:bitstring,=true) = send_client_finished_client_auth(ccvl,cfk,log5) in
    insert oneRTTClientDataKey(cr,sr,certC,cert,dk);
    out(io,ClientFinishedOut(cfin)))
|
!N3
  (in(io,e:bitstring);
   get oneRTTClientDataKey(cr,sr,certC,certS,k) in
   let m = dec(k,e) in
   event RecvClient(cr,sr,certC,certS,m))
| 
!N4
  (in(io,m:bitstring);
   get oneRTTClientDataKey(cr,sr,certC,certS,k) in
   event SendClient(cr,sr,certC,certS,m);
   out(io,enc(k,m)))
  | 
  !N5
  (in(io,());
   get oneRTTClientDataKey(cr,sr,certC,certS,k) in
   event SendClient(cr,sr,certC,certS,secret_msg2);
    out(io,enc(k,secret_msg2)))
*)
.


let Server = 
 !N6
  (in(io,ClientHello(cr,gx));
   let (sr:nonce,gy:elt,xES:extracted) = recv_client_hello(hk,cr,gx) in
   out(io,ServerHelloOut(sr,gy));
   in(io,log:bitstring);
   let sil = ServerHelloLogInfo(cr,gx,sr,gy) in
   let (hk:key,=true) = onertt_hs_keys(sil,xES,log) in
   out(io,hk);
   in(io,(cert:certificate,log1:bitstring));
   get serverLongTermKeys(=cert,sk,gss,ss) in
   let scl = ServerCertificateLogInfo(sil,cert) in
   let (sg:bitstring,=true) = send_server_certificate_verify(scl,sk,log1) in
   out(io,ServerCertificateVerifyOut(sg));
   in(io,log2:bitstring);
   let scvl = ServerCertificateVerifyLogInfo(scl,sg) in
   let (cfk:key,ts0:key,m:bitstring,=true) = send_server_finished(scvl,xES,xES,log2) in
   out(io,ServerFinishedOut(m));
   in(io,log3:bitstring);
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let (dk:key,=true) = onertt_data_keys(sfl,ts0,log3) in
   insert oneRTTServerFalseStartKey(cr,sr,cert,dk,cfk,empty_bytes);
   out(io,());
   in(io,ClientFinishedIn(cfin:bitstring,log4:bitstring));
   if (check_client_finished_no_auth(sfl,cfin,cfk,log4)) then
   insert oneRTTServerDataKey(cr,sr,anon_cert,cert,dk))
(*|
 !N7
   (in(io,ClientHello(cr,gx));
   let (sr:nonce,gy:elt,xES:extracted) = recv_client_hello(cr,gx) in
   out(io,ServerHelloOut(sr,gy));
   in(io,log:bitstring);
   let sil = ServerHelloLogInfo(cr,gx,sr,gy) in
   let (hk:key,=true) = onertt_hs_keys(sil,xES,log) in
   out(io,hk);
   in(io,(cert:certificate,log1:bitstring));
   get serverLongTermKeys(=cert,sk,gss,ss) in
   let scl = ServerCertificateLogInfo(sil,cert) in
   let (sg:bitstring,=true) = send_server_certificate_verify(scl,sk,log1) in
   out(io,ServerCertificateVerifyOut(sg));
   in(io,log2:bitstring);
   let scvl = ServerCertificateVerifyLogInfo(scl,sg) in
   let (cfk:key,ts0:key,m:bitstring,=true) = send_server_finished(scvl,xES,xES,log2) in
   out(io,ServerFinishedOut(m));
   in(io,log3:bitstring);
   let sfl = ServerFinishedLogInfo(scvl,m) in
   let (dk:key,=true) = onertt_data_keys(sfl,ts0,log3) in
   insert oneRTTServerFalseStartKey(cr,sr,cert,dk,cfk,empty_bytes);
   out(io,());
   in(io,ClientFinishedAuthIn(certC,cv,cfin,log4,log5));
   let ccl = ClientCertificateLogInfo(sfl,certC) in
   if (check_client_finished_client_auth(sfl,certC,cv,cfin,cfk,log4,log5)) then
   insert oneRTTServerDataKey(cr,sr,certC,cert,dk))
 | 
  !N8 (in(io,e:bitstring);
   get oneRTTServerDataKey(cr,sr,certC,cert,k) in
   let m = dec(k,e) in
   event RecvServer(cr,sr,certC,cert,m))
  | 
  !N9 (in(io,m:bitstring);
   get oneRTTServerFalseStartKey(cr,sr,cert,k,cfk,log) in
   event SendServer0(cr,sr,cert,m);
   out(io,enc(k,m)))
  | 
  !N10 
(in(io,m:bitstring);
   get oneRTTServerFalseStartKey(cr,sr,cert,k,cfk,log) in
   event SendServer0(cr,sr,cert,secret_msg1);
    out(io,enc(k,secret_msg1)))
|
  !N11 (in(io,m:bitstring);
   get oneRTTServerDataKey(cr,sr,certC,cert,k) in
   event SendServer(cr,sr,certC,cert,m);
   out(io,enc(k,m)))
|
  !N12 (in(io,m:bitstring);
   get oneRTTServerDataKey(cr,sr,certC,cert,k) in
   event SendServer(cr,sr,certC,cert,secret_msg3);
   out(io,enc(k,secret_msg3)))
*).

(*
let Server0() = 
 !(in(io,(ClientHello(cr,gx)));
   new sr:nonce;
   let (y:key,gy:key) = dh_keygen() in
   get serverLongTermKeys(cert,sk,gss,ss) in
   let ss = expH_P256(x,gs) in
   let xSS = HKDF_extract(zero_key,ss) in
   let dk0 = HKDF_expand(xSS,dk0_label,log) in
   insert zeroRTTServerKey(cr,anon_cert,certS,gs,dk0);
   let shlog = (ClientHello(cr,gy),ServerHello(sr,gy)) in
   let s = DH_P256(y,gx) in
   let xES = HKDF_extract(zero_key,s) in
   let hk =  HKDF_expand(xES,hk_label,shlog) in    
   insert oneRTTServerHSKey(cr,sr,xES,xSS,hk,certS,shlog);
   out(io,(ServerHello(sr,gy)))
  )
 .
 *)

process 
  in(io,());
  new hk: hashkey;
  new kseed:keyseed;
  let skS = skgen(kseed) in
  let pkS = pkcert(kseed) in
  let (s:key,gs:elt) = dh_keygen() in
  insert serverLongTermKeys(pkS,skS,gs,s);
  out(io,(pkS,gs));
(Client | Server
  |
(!N13 in(io, (pkx: certificate, skx: skey, gsx: elt, sx: key));
  if pkx <> pkS then
  insert serverLongTermKeys(pkx,skx,gsx,sx))
  |
(* !N14 (in(io,());
  new kseed:keyseed;
  let sk = skgen(kseed) in
  let pk = pkcert(kseed) in
  insert clientLongTermKeys(pk,sk);
  out(io,pk))
 |*)
 (!N15 in(io,(cert:certificate));
   get serverLongTermKeys(=cert,sk,gs,s) in
   new s: seed;
   out(io,sign(sk,elt2bitstring(gs), s)))
(*  |
 (!N16 in(io,(gs:elt,cert:certificate,sg:bitstring));
   let kb = elt2bitstring(gs) in
   if verify(cert,kb,sg) then
   insert clientCache(gs,cert))*)
   | hashoracle
)
